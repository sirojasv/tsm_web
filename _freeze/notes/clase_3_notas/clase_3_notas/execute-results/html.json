{
  "hash": "6428ac464b3e1610ffcc656897d91ecd",
  "result": {
    "markdown": "---\n# Título y Autor\ntitle: \"Notas clase 3: Introducción a Tidyverse\"\nsubtitle: |\n    | Curso: Metodología Cuantitativa.\n    | Magíster en Trabajo Social, Pontificia Universidad Católica de Chile.\nauthor: \"Sebastián Rojas Vergara\"\n# date: \n# abstract: \n# thanks:\n# order: \n# Opciones de formato\nformat: \n  html:\n    # Fuente\n    # Despliegue de código\n    code-fold: false\n    code-line-numbers: true\n    # Tema\n    theme:\n      light: flatly\n      dark: darkly\n    highlight-style: github\n    # Autocontenido\n    self-contained: true\n    # estilos\n    css: styles.css\n# Tabla de contenidos\ntoc: true\ntoc-depth: 4\ntoc-location: right\n# Numeración\nnumber-sections: true\n# Figuras\nfig-align: center\nfig-cap-location: top\n# Notas al pie\nfootnotes-hover: true\n# Lenguaje\nlang: \"es\"\n# Ejecución de código\ncomments: false\nexecute: \n  echo: true\n---\n\n\n<img src=\"images/logo_puc_bn.png\" alt=\"Logo PUC\" style=\"position: fixed; top: 0; right: 0; width: 150px; height: 90px;\"/>\n\n## Introducción {.unnumbered}\n\nEn este documento se profundizará en las funciones disponibles en tidyverse para el procesamiento, limpieza y análisis de datos. En particular, aquellas provenientes del paquete `dplyr`.\n\nPara esta sesión trabajaremos con un conjunto de datos más lúdico. En concreto, aquellos disponibles en el paquete `pokemon`. Este contiene información para 949 filas, que corresponden a los pokémon que han salido en cada generación del famoso videojuego de Nintendo y 22 columnas, que incluyen atributos para cada uno de ellos.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Instalar paquetes y cargar librerias\nif (!require(\"pokemon\")) install.packages(\"pokemon\")\nlibrary(pokemon)\nlibrary(tidyverse)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Asignar conjunto de datos a objeto\ndata_poke <- pokemon\n```\n:::\n\n\n::: callout-note\nTodas los códigos utilizarán el nuevo pipe de R `|>`, disponible desde R 4.1.0.\n:::\n\n## glimpse()\n\nPermite obtener una vista rápida de la estructura del conjunto de datos, mostrando información como:\n\n-   Número de filas y columnas.\n-   Nombre y tipo de dato para las variables.\n-   Algunos datos de ejemplo.\n\nSe recomienda usar esta función cuando se inicia el trabajo con un conjunto de datos, para conocer cuál es la información disponible. También se sugiere revisar la estructura de la base de datos en la medida que se realizan modificaciones. Por ejemplo:\n\n-   Cuando se agregan o eliminan columnas.\n-   Cuando se modifican columnas cambiando su tipo de dato.\n-   Variables renombradas, etc.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata_poke |> glimpse()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRows: 949\nColumns: 22\n$ id              <dbl> 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16,…\n$ pokemon         <chr> \"bulbasaur\", \"ivysaur\", \"venusaur\", \"charmander\", \"cha…\n$ species_id      <dbl> 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16,…\n$ height          <dbl> 0.7, 1.0, 2.0, 0.6, 1.1, 1.7, 0.5, 1.0, 1.6, 0.3, 0.7,…\n$ weight          <dbl> 6.9, 13.0, 100.0, 8.5, 19.0, 90.5, 9.0, 22.5, 85.5, 2.…\n$ base_experience <dbl> 64, 142, 236, 62, 142, 240, 63, 142, 239, 39, 72, 178,…\n$ type_1          <chr> \"grass\", \"grass\", \"grass\", \"fire\", \"fire\", \"fire\", \"wa…\n$ type_2          <chr> \"poison\", \"poison\", \"poison\", NA, NA, \"flying\", NA, NA…\n$ hp              <dbl> 45, 60, 80, 39, 58, 78, 44, 59, 79, 45, 50, 60, 40, 45…\n$ attack          <dbl> 49, 62, 82, 52, 64, 84, 48, 63, 83, 30, 20, 45, 35, 25…\n$ defense         <dbl> 49, 63, 83, 43, 58, 78, 65, 80, 100, 35, 55, 50, 30, 5…\n$ special_attack  <dbl> 65, 80, 100, 60, 80, 109, 50, 65, 85, 20, 25, 90, 20, …\n$ special_defense <dbl> 65, 80, 100, 50, 65, 85, 64, 80, 105, 20, 25, 80, 20, …\n$ speed           <dbl> 45, 60, 80, 65, 80, 100, 43, 58, 78, 45, 30, 70, 50, 3…\n$ color_1         <chr> \"#78C850\", \"#78C850\", \"#78C850\", \"#F08030\", \"#F08030\",…\n$ color_2         <chr> \"#A040A0\", \"#A040A0\", \"#A040A0\", NA, NA, \"#A890F0\", NA…\n$ color_f         <chr> \"#81A763\", \"#81A763\", \"#81A763\", NA, NA, \"#DE835E\", NA…\n$ egg_group_1     <chr> \"monster\", \"monster\", \"monster\", \"monster\", \"monster\",…\n$ egg_group_2     <chr> \"plant\", \"plant\", \"plant\", \"dragon\", \"dragon\", \"dragon…\n$ url_icon        <chr> \"//archives.bulbagarden.net/media/upload/7/7b/001MS6.p…\n$ generation_id   <dbl> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, …\n$ url_image       <chr> \"https://raw.githubusercontent.com/HybridShivam/Pokemo…\n```\n:::\n:::\n\n\nA continuación se detallan algunos campos relevantes con los que trabajaremos:\n\n| Columna         | Descripción                                                        |\n|----------------|-----------------------------------------------|\n| id              | Identificador numérico de cada pokémon                             |\n| pokemon         | Identificador de cada pokémon con su nombre                        |\n| height          | Altura del pokémon                                                 |\n| weight          | Peso del pokémon                                                   |\n| base_experience | Experiencia base numérica del pokémon                              |\n| type_1          | Tipo primario de cada pokémon                                      |\n| type_2          | Tipo secundario de cada pokémon                                    |\n| hp              | Valor numérico que representa la vida de cada pokémon              |\n| attack          | Valor numérico que representa el ataque de cada pokémon            |\n| defense         | Vector numérico que representa la defensa de cada pokémon          |\n| special_defense | Vector numérico que representa la defensa especial de cada pokémon |\n| speed           | Vector numérico que representa la velocidad de cada pokémon        |\n| color_1         | Color primario de cada pokémon                                     |\n| color_2         | Color secundario de cada pokémon                                   |\n| generation_id   | Valor que representa la generación de cada pokémon                 |\n\n: Variables conjunto de datos pokémon {#tbl-variables}\n\n## select()\n\nSe utiliza para seleccionar columnas de un conjunto de datos. Este procedimiento puede agruparse en dos grandes tipos:\n\na.  Selección positiva: indicar las variables **que se desea incluir**.\nb.  Selección negativa: indicar las variables **que no se desea incluir**.\n\nLa forma en que se realice la selección dependerá principalmente de las preferencias de cada analista, del tamaño del conjunto de datos y si las variables -o grupos de ellas- comparten algún patrón en sus sus nombres.\n\nIndependiente del tipo de selección, se pueden usar los siguientes métodos:\n\n1.  Especificando las variables a seleccionar por nombre y/o posición.\n2.  Utilizar otras funciones como `selection helpers`.\n3.  Por un grupo de variables indicadas en un vector.\n4.  Usando `where()`, que aplicará una función a todas las variables y retornará aquellas con `TRUE`. Este método permite, entre otras opciones, seleccionar por tipo de dato.\n\n### Por nombre y/o posición\n\nEn este caso, la selección de columnas se realiza indicando el nombre o posición de las columnas.\n\n-   Si se especifican los nombres, estos deben estar escritos tal y como aparecen en el conjunto de datos, respetando mayúsculas y minúsculas. Para evitar problemas en el trabajo con los datos se recomienda fuertemente tener estandarizados los nombres de variables.\n- Usualmente es más recomendable emplear nombres.\n-   La función `select()` retornará el tibble con las variables indicadas, en el mismo orden en el que se especificó la selección.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Seleccionamos por posición \ndata_poke |> \n  select(2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 949 × 1\n   pokemon   \n   <chr>     \n 1 bulbasaur \n 2 ivysaur   \n 3 venusaur  \n 4 charmander\n 5 charmeleon\n 6 charizard \n 7 squirtle  \n 8 wartortle \n 9 blastoise \n10 caterpie  \n# ℹ 939 more rows\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Selección por nombre\ndata_poke |> \n  select(pokemon)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 949 × 1\n   pokemon   \n   <chr>     \n 1 bulbasaur \n 2 ivysaur   \n 3 venusaur  \n 4 charmander\n 5 charmeleon\n 6 charizard \n 7 squirtle  \n 8 wartortle \n 9 blastoise \n10 caterpie  \n# ℹ 939 more rows\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Posición - Varias columnas\ndata_poke |> \n  select(2, 3, 6, 7)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 949 × 4\n   pokemon    species_id base_experience type_1\n   <chr>           <dbl>           <dbl> <chr> \n 1 bulbasaur           1              64 grass \n 2 ivysaur             2             142 grass \n 3 venusaur            3             236 grass \n 4 charmander          4              62 fire  \n 5 charmeleon          5             142 fire  \n 6 charizard           6             240 fire  \n 7 squirtle            7              63 water \n 8 wartortle           8             142 water \n 9 blastoise           9             239 water \n10 caterpie           10              39 bug   \n# ℹ 939 more rows\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Nombre - Varias columnas\ndata_poke |> \n  select(pokemon, species_id, base_experience, type_1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 949 × 4\n   pokemon    species_id base_experience type_1\n   <chr>           <dbl>           <dbl> <chr> \n 1 bulbasaur           1              64 grass \n 2 ivysaur             2             142 grass \n 3 venusaur            3             236 grass \n 4 charmander          4              62 fire  \n 5 charmeleon          5             142 fire  \n 6 charizard           6             240 fire  \n 7 squirtle            7              63 water \n 8 wartortle           8             142 water \n 9 blastoise           9             239 water \n10 caterpie           10              39 bug   \n# ℹ 939 more rows\n```\n:::\n:::\n\n\nOtra opción es realizar una selección por rango. Aquí podemos notar que el programa internamente está usando la posición de las columnas para realizar la selección.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Posición - por rango\ndata_poke |> \n  select(1:7, 19)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 949 × 8\n      id pokemon    species_id height weight base_experience type_1 egg_group_2\n   <dbl> <chr>           <dbl>  <dbl>  <dbl>           <dbl> <chr>  <chr>      \n 1     1 bulbasaur           1    0.7    6.9              64 grass  plant      \n 2     2 ivysaur             2    1     13               142 grass  plant      \n 3     3 venusaur            3    2    100               236 grass  plant      \n 4     4 charmander          4    0.6    8.5              62 fire   dragon     \n 5     5 charmeleon          5    1.1   19               142 fire   dragon     \n 6     6 charizard           6    1.7   90.5             240 fire   dragon     \n 7     7 squirtle            7    0.5    9                63 water  water1     \n 8     8 wartortle           8    1     22.5             142 water  water1     \n 9     9 blastoise           9    1.6   85.5             239 water  water1     \n10    10 caterpie           10    0.3    2.9              39 bug    <NA>       \n# ℹ 939 more rows\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Nombre - por rango\ndata_poke |> \n  select(id:type_1, generation_id)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 949 × 8\n      id pokemon   species_id height weight base_experience type_1 generation_id\n   <dbl> <chr>          <dbl>  <dbl>  <dbl>           <dbl> <chr>          <dbl>\n 1     1 bulbasaur          1    0.7    6.9              64 grass              1\n 2     2 ivysaur            2    1     13               142 grass              1\n 3     3 venusaur           3    2    100               236 grass              1\n 4     4 charmand…          4    0.6    8.5              62 fire               1\n 5     5 charmele…          5    1.1   19               142 fire               1\n 6     6 charizard          6    1.7   90.5             240 fire               1\n 7     7 squirtle           7    0.5    9                63 water              1\n 8     8 wartortle          8    1     22.5             142 water              1\n 9     9 blastoise          9    1.6   85.5             239 water              1\n10    10 caterpie          10    0.3    2.9              39 bug                1\n# ℹ 939 more rows\n```\n:::\n:::\n\n\nPara realizar una selección negativa en estos casos se puede anteponer el signo menos `-`\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Posición - por rango, negativa\ndata_poke |> \n  select(-(1:7))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 949 × 15\n   type_2    hp attack defense special_attack special_defense speed color_1\n   <chr>  <dbl>  <dbl>   <dbl>          <dbl>           <dbl> <dbl> <chr>  \n 1 poison    45     49      49             65              65    45 #78C850\n 2 poison    60     62      63             80              80    60 #78C850\n 3 poison    80     82      83            100             100    80 #78C850\n 4 <NA>      39     52      43             60              50    65 #F08030\n 5 <NA>      58     64      58             80              65    80 #F08030\n 6 flying    78     84      78            109              85   100 #F08030\n 7 <NA>      44     48      65             50              64    43 #6890F0\n 8 <NA>      59     63      80             65              80    58 #6890F0\n 9 <NA>      79     83     100             85             105    78 #6890F0\n10 <NA>      45     30      35             20              20    45 #A8B820\n# ℹ 939 more rows\n# ℹ 7 more variables: color_2 <chr>, color_f <chr>, egg_group_1 <chr>,\n#   egg_group_2 <chr>, url_icon <chr>, generation_id <dbl>, url_image <chr>\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Nombre - por rango, negativa\ndata_poke |> \n  select(-(id:type_1))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 949 × 15\n   type_2    hp attack defense special_attack special_defense speed color_1\n   <chr>  <dbl>  <dbl>   <dbl>          <dbl>           <dbl> <dbl> <chr>  \n 1 poison    45     49      49             65              65    45 #78C850\n 2 poison    60     62      63             80              80    60 #78C850\n 3 poison    80     82      83            100             100    80 #78C850\n 4 <NA>      39     52      43             60              50    65 #F08030\n 5 <NA>      58     64      58             80              65    80 #F08030\n 6 flying    78     84      78            109              85   100 #F08030\n 7 <NA>      44     48      65             50              64    43 #6890F0\n 8 <NA>      59     63      80             65              80    58 #6890F0\n 9 <NA>      79     83     100             85             105    78 #6890F0\n10 <NA>      45     30      35             20              20    45 #A8B820\n# ℹ 939 more rows\n# ℹ 7 more variables: color_2 <chr>, color_f <chr>, egg_group_1 <chr>,\n#   egg_group_2 <chr>, url_icon <chr>, generation_id <dbl>, url_image <chr>\n```\n:::\n:::\n\n\n### Usando `selection helpers`\n\nTidyverse tiene un paquete llamado `tidyselect` que trabaja de manera interna y cuenta con algunas funciones que facilitan el proceso de selección de variables (entre otras cosas):\n\n-   `everything()`: selecciona todas las variables.\n-   `last_col()`: selecciona la última variable.\n-   `group_cols()`: selecciona las columnas agrupadas.\n-   `starts_with`: selecciona las variables con un prefijo especificado.\n-   `ends_with`: selecciona las variables con un sufijo especificado.\n-   `contains`: selecciona las variables que contienen uno más caracteres especificados.\n-   `matches`: seleccion variables por expresiones regulares. Estas son formas de especificarle al programa que encuentre un patrón específico en una cadena de caracteres.\n-   `num_range`: selecciona variables con un patrón numérico. Por ejemplo \"p01\", \"p02\", \"p03\", etc.\n\nA continuación se muestran algunos ejemplos aplicando estas funciones:\n\nEn este caso, se seleccionan todas las columnas, menos \"id\" y \"url_image\".\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata_poke |> \n  select(everything(), -id, -url_image)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 949 × 20\n   pokemon   species_id height weight base_experience type_1 type_2    hp attack\n   <chr>          <dbl>  <dbl>  <dbl>           <dbl> <chr>  <chr>  <dbl>  <dbl>\n 1 bulbasaur          1    0.7    6.9              64 grass  poison    45     49\n 2 ivysaur            2    1     13               142 grass  poison    60     62\n 3 venusaur           3    2    100               236 grass  poison    80     82\n 4 charmand…          4    0.6    8.5              62 fire   <NA>      39     52\n 5 charmele…          5    1.1   19               142 fire   <NA>      58     64\n 6 charizard          6    1.7   90.5             240 fire   flying    78     84\n 7 squirtle           7    0.5    9                63 water  <NA>      44     48\n 8 wartortle          8    1     22.5             142 water  <NA>      59     63\n 9 blastoise          9    1.6   85.5             239 water  <NA>      79     83\n10 caterpie          10    0.3    2.9              39 bug    <NA>      45     30\n# ℹ 939 more rows\n# ℹ 11 more variables: defense <dbl>, special_attack <dbl>,\n#   special_defense <dbl>, speed <dbl>, color_1 <chr>, color_2 <chr>,\n#   color_f <chr>, egg_group_1 <chr>, egg_group_2 <chr>, url_icon <chr>,\n#   generation_id <dbl>\n```\n:::\n:::\n\n\nEn el siguiente ejemplo se realiza un doble `select()`. Primero para eliminar la última columna del conjunto de datos. Luego, se selecciona la columna que corresponde al nombre del pokémon; la última, que en este caso es el identificador de la generación y luego la columna que muestra el tipo del pokémon.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(1234) # Esta semilla permite replicar la selección aleatoria\n\ndata_poke |> \n  select(-url_image) |> \n  select(pokemon, last_col(), type_1) |> \n  slice_sample(n = 10) # Selección aleatoria\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 10 × 3\n   pokemon              generation_id type_1  \n   <chr>                        <dbl> <chr>   \n 1 masquerain                       3 bug     \n 2 scizor-mega                     NA bug     \n 3 greninja-battle-bond            NA water   \n 4 electrode                        1 electric\n 5 golurk                           5 ground  \n 6 vulpix-alola                    NA ice     \n 7 landorus-incarnate               5 ground  \n 8 minior-green-meteor             NA rock    \n 9 bibarel                          4 normal  \n10 pikachu-kalos-cap               NA electric\n```\n:::\n:::\n\n\n::: callout-tip\nLa función `set.seed()` permite replicar un procedimiento aleatorio, para obtener el mismo resultado con cada ejecución. Es sumamente útil para darle reproducibilidad a un proceso que implique una selección aleatoria.\n\nPara quienes estén interesados sobre números aleatorios en los computadores, pueden revisar este video del canal de YouTube [Derivando](https://www.youtube.com/watch?v=RzEjqJHW-NU)-\n:::\n\nEn el siguiente código se seleccionan los identificadores y nombres, pero además se usa la función `starts_with()` para seleccionar todo lo que comience con \"type\".\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata_poke |> \n  select(id, pokemon, starts_with(\"type\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 949 × 4\n      id pokemon    type_1 type_2\n   <dbl> <chr>      <chr>  <chr> \n 1     1 bulbasaur  grass  poison\n 2     2 ivysaur    grass  poison\n 3     3 venusaur   grass  poison\n 4     4 charmander fire   <NA>  \n 5     5 charmeleon fire   <NA>  \n 6     6 charizard  fire   flying\n 7     7 squirtle   water  <NA>  \n 8     8 wartortle  water  <NA>  \n 9     9 blastoise  water  <NA>  \n10    10 caterpie   bug    <NA>  \n# ℹ 939 more rows\n```\n:::\n:::\n\n\nO aquellas que terminen con \"ght\", empleando la función `ends_with()`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata_poke |> \n  select(id, pokemon, ends_with(\"ght\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 949 × 4\n      id pokemon    height weight\n   <dbl> <chr>       <dbl>  <dbl>\n 1     1 bulbasaur     0.7    6.9\n 2     2 ivysaur       1     13  \n 3     3 venusaur      2    100  \n 4     4 charmander    0.6    8.5\n 5     5 charmeleon    1.1   19  \n 6     6 charizard     1.7   90.5\n 7     7 squirtle      0.5    9  \n 8     8 wartortle     1     22.5\n 9     9 blastoise     1.6   85.5\n10    10 caterpie      0.3    2.9\n# ℹ 939 more rows\n```\n:::\n:::\n\n\nPor su parte, la función `contains()` es más amplia, pues seleccionará todas las variables que incluyan el string especificado.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata_poke |> \n  select(id, pokemon, contains(\"_\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 949 × 16\n      id pokemon    species_id base_experience type_1 type_2 special_attack\n   <dbl> <chr>           <dbl>           <dbl> <chr>  <chr>           <dbl>\n 1     1 bulbasaur           1              64 grass  poison             65\n 2     2 ivysaur             2             142 grass  poison             80\n 3     3 venusaur            3             236 grass  poison            100\n 4     4 charmander          4              62 fire   <NA>               60\n 5     5 charmeleon          5             142 fire   <NA>               80\n 6     6 charizard           6             240 fire   flying            109\n 7     7 squirtle            7              63 water  <NA>               50\n 8     8 wartortle           8             142 water  <NA>               65\n 9     9 blastoise           9             239 water  <NA>               85\n10    10 caterpie           10              39 bug    <NA>               20\n# ℹ 939 more rows\n# ℹ 9 more variables: special_defense <dbl>, color_1 <chr>, color_2 <chr>,\n#   color_f <chr>, egg_group_1 <chr>, egg_group_2 <chr>, url_icon <chr>,\n#   generation_id <dbl>, url_image <chr>\n```\n:::\n:::\n\n\nY la función `matches()` es mucho más potente, pues se le puede especificar cualquier patrón a través de una expresión regular. Por ejemplo, ahora seleccionaremos todas las variables que incluyan solamente letras minúsculas en su nombre.\n\nEsta expresión regular se puede definir del siguiente modo:\n\n-   `^`: indica el inicio del string.\n-   `[a-z]`: indica caracteres desde la \"a\" a la \"z\" en minúscula.\n-   `*`: indica que deben ser 0 o más repeticiones de esos caracteres.\n-   `$`: indica el fin del string.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata_poke |> \n  select(matches(\"^[a-z]*$\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 949 × 8\n      id pokemon    height weight    hp attack defense speed\n   <dbl> <chr>       <dbl>  <dbl> <dbl>  <dbl>   <dbl> <dbl>\n 1     1 bulbasaur     0.7    6.9    45     49      49    45\n 2     2 ivysaur       1     13      60     62      63    60\n 3     3 venusaur      2    100      80     82      83    80\n 4     4 charmander    0.6    8.5    39     52      43    65\n 5     5 charmeleon    1.1   19      58     64      58    80\n 6     6 charizard     1.7   90.5    78     84      78   100\n 7     7 squirtle      0.5    9      44     48      65    43\n 8     8 wartortle     1     22.5    59     63      80    58\n 9     9 blastoise     1.6   85.5    79     83     100    78\n10    10 caterpie      0.3    2.9    45     30      35    45\n# ℹ 939 more rows\n```\n:::\n:::\n\n\n::: callout-note\nExpresiones regulares no es un contenido que se verá en el curso. Solo se muestra un ejemplo para que conozcan que existe esa opción.\n:::\n\nY en cuanto a la función `num_range()`, esta es particularmente útil en conjuntos de datos que tienen nombres correlativos usando como prefijo una letra.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata_poke |> \n  select(pokemon, num_range(\"type_\", 1:2))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 949 × 3\n   pokemon    type_1 type_2\n   <chr>      <chr>  <chr> \n 1 bulbasaur  grass  poison\n 2 ivysaur    grass  poison\n 3 venusaur   grass  poison\n 4 charmander fire   <NA>  \n 5 charmeleon fire   <NA>  \n 6 charizard  fire   flying\n 7 squirtle   water  <NA>  \n 8 wartortle  water  <NA>  \n 9 blastoise  water  <NA>  \n10 caterpie   bug    <NA>  \n# ℹ 939 more rows\n```\n:::\n:::\n\n\n### Por variables indicadas en un vector\n\nOtra forma para realizar la selección de variables es a través de un vector que incluya los nombres de cada columna. Existen dos funciones para esta operación:\n\n-   `all_of()`: define un vector de caracteres con los nombres de variables. Todos los nombres deben estar en el conjunto de datos o lanzará un error.\n\n-   `any_of()`: al igual que la función anterior, define un vector de caracteres con los nombres. Sin embargo, no arrojará error si este no existe en el conjunto.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnombres_inicial <- c(\"id\", \"pokemon\", \"nombre_no_existe\")\ndata_poke |> select(any_of(nombres_inicial)) # Si usáramos all_of daría error.\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 949 × 2\n      id pokemon   \n   <dbl> <chr>     \n 1     1 bulbasaur \n 2     2 ivysaur   \n 3     3 venusaur  \n 4     4 charmander\n 5     5 charmeleon\n 6     6 charizard \n 7     7 squirtle  \n 8     8 wartortle \n 9     9 blastoise \n10    10 caterpie  \n# ℹ 939 more rows\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nnombres <- names(data_poke) # Función names() entrega nombres de columnas del dataframe\ndata_poke |> select(any_of(nombres))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 949 × 22\n      id pokemon    species_id height weight base_experience type_1 type_2    hp\n   <dbl> <chr>           <dbl>  <dbl>  <dbl>           <dbl> <chr>  <chr>  <dbl>\n 1     1 bulbasaur           1    0.7    6.9              64 grass  poison    45\n 2     2 ivysaur             2    1     13               142 grass  poison    60\n 3     3 venusaur            3    2    100               236 grass  poison    80\n 4     4 charmander          4    0.6    8.5              62 fire   <NA>      39\n 5     5 charmeleon          5    1.1   19               142 fire   <NA>      58\n 6     6 charizard           6    1.7   90.5             240 fire   flying    78\n 7     7 squirtle            7    0.5    9                63 water  <NA>      44\n 8     8 wartortle           8    1     22.5             142 water  <NA>      59\n 9     9 blastoise           9    1.6   85.5             239 water  <NA>      79\n10    10 caterpie           10    0.3    2.9              39 bug    <NA>      45\n# ℹ 939 more rows\n# ℹ 13 more variables: attack <dbl>, defense <dbl>, special_attack <dbl>,\n#   special_defense <dbl>, speed <dbl>, color_1 <chr>, color_2 <chr>,\n#   color_f <chr>, egg_group_1 <chr>, egg_group_2 <chr>, url_icon <chr>,\n#   generation_id <dbl>, url_image <chr>\n```\n:::\n:::\n\n\n### Aplicando funciones a variables\n\nMuchas veces podemos estar interesados/as en realizar selecciones según el tipo de variable o aplicando alguna función. En estos casos `where()` se vuelve muy útil. Este aplica una función a todas las variables y selecciona aquellas cuyo valor de la función sea `TRUE`.\n\nPor ejemplo, podríamos aplicar funciones para consultar el tipo de dato de la columna. Esta devolverá `TRUE` en caso de que la columna sea del tipo especificado y `FALSE` en todos los otros escenarios.\n\n-   `is.numeric()`: devuelve TRUE si la variable es `numeric`.\n-   `is.character()`: devuelve TRUE si la variable es `character`.\n-   `is.factor()`: devuelve TRUE si la variable es `factor`.\n-   `is.logical()`: devuelve TRUE si la variable es `logical`.\n-   `is.date()`: devuelve TRUE si la variable es `date`.\n\nEl código que se presenta en el siguiente bloque seleccionará todas las variables de tipo `numeric`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata_poke |> select(where(is.numeric))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 949 × 12\n      id species_id height weight base_experience    hp attack defense\n   <dbl>      <dbl>  <dbl>  <dbl>           <dbl> <dbl>  <dbl>   <dbl>\n 1     1          1    0.7    6.9              64    45     49      49\n 2     2          2    1     13               142    60     62      63\n 3     3          3    2    100               236    80     82      83\n 4     4          4    0.6    8.5              62    39     52      43\n 5     5          5    1.1   19               142    58     64      58\n 6     6          6    1.7   90.5             240    78     84      78\n 7     7          7    0.5    9                63    44     48      65\n 8     8          8    1     22.5             142    59     63      80\n 9     9          9    1.6   85.5             239    79     83     100\n10    10         10    0.3    2.9              39    45     30      35\n# ℹ 939 more rows\n# ℹ 4 more variables: special_attack <dbl>, special_defense <dbl>, speed <dbl>,\n#   generation_id <dbl>\n```\n:::\n:::\n\n\nY este todas las variables de tipo `character`\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata_poke |> select(where(is.character))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 949 × 10\n   pokemon    type_1 type_2 color_1 color_2 color_f egg_group_1 egg_group_2\n   <chr>      <chr>  <chr>  <chr>   <chr>   <chr>   <chr>       <chr>      \n 1 bulbasaur  grass  poison #78C850 #A040A0 #81A763 monster     plant      \n 2 ivysaur    grass  poison #78C850 #A040A0 #81A763 monster     plant      \n 3 venusaur   grass  poison #78C850 #A040A0 #81A763 monster     plant      \n 4 charmander fire   <NA>   #F08030 <NA>    <NA>    monster     dragon     \n 5 charmeleon fire   <NA>   #F08030 <NA>    <NA>    monster     dragon     \n 6 charizard  fire   flying #F08030 #A890F0 #DE835E monster     dragon     \n 7 squirtle   water  <NA>   #6890F0 <NA>    <NA>    monster     water1     \n 8 wartortle  water  <NA>   #6890F0 <NA>    <NA>    monster     water1     \n 9 blastoise  water  <NA>   #6890F0 <NA>    <NA>    monster     water1     \n10 caterpie   bug    <NA>   #A8B820 <NA>    <NA>    bug         <NA>       \n# ℹ 939 more rows\n# ℹ 2 more variables: url_icon <chr>, url_image <chr>\n```\n:::\n:::\n\n\nY de igual forma podríamos aplicar otra función para obtener solo las variables numéricas cuya media aritmética sea superior a 50.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata_poke |> select(where(~ is.numeric(.x) && mean(.x, na.rm = T) > 50))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 949 × 10\n      id species_id weight base_experience    hp attack defense special_attack\n   <dbl>      <dbl>  <dbl>           <dbl> <dbl>  <dbl>   <dbl>          <dbl>\n 1     1          1    6.9              64    45     49      49             65\n 2     2          2   13               142    60     62      63             80\n 3     3          3  100               236    80     82      83            100\n 4     4          4    8.5              62    39     52      43             60\n 5     5          5   19               142    58     64      58             80\n 6     6          6   90.5             240    78     84      78            109\n 7     7          7    9                63    44     48      65             50\n 8     8          8   22.5             142    59     63      80             65\n 9     9          9   85.5             239    79     83     100             85\n10    10         10    2.9              39    45     30      35             20\n# ℹ 939 more rows\n# ℹ 2 more variables: special_defense <dbl>, speed <dbl>\n```\n:::\n:::\n\n\n::: callout-important\nEste código puede ser más complejo, por lo que puede resultar útil explicar algunos conceptos:\n\n-   En primer lugar, se utiliza `where()` para definir una función, la cual es denotada por la virgulilla `~`.\n-   Esta función evalúa para cada elemento, el cual es denotado genéricamente como `.x` si es que es de tipo numérico.\n-   Además, para cada elemento, evaluará que la media, a la cual se le remueven los casos perdidos, sea superior a 50.\n-   Para estas operaciones se utiliza el operador `&&` en vez de `&`. Esto se debe a que estamos evaluando que ambas condiciones sean verdaderas, pero **para cada columna individualmente**. Para más información se puede revisar este [link](https://www.geeksforgeeks.org/difference-between-and-in-r/).\n-   Cuando se usa `&&`, solo se evalúa la segunda condición cuando la primera es verdadera. Es decir, solo aquellas variables que sean numéricas se les evaluará si su media aritmética es superior a 50. Para quienes cumplan ambos criterios, serán seleccionadas.\n:::\n\n## rename()\n\nEsta función permite renombrar columnas siguiendo la estructura `nombre_nuevo = nombre_antiguo`. Para ello se pueden usar al menos tres métodos\n\n1.  Especificar por nombre.\n2.  Usando un vector.\n3.  Usando funciones.\n\n### Por nombre\n\nEn su formulación más simple, basta con especificar el nombre nuevo y asignarlo al nombre que anteriormente tenía la variable.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata_poke |> \n  rename(peso = weight,\n         altura = height,\n         primer_tipo = type_1) |> \n  select(peso, altura, primer_tipo)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 949 × 3\n    peso altura primer_tipo\n   <dbl>  <dbl> <chr>      \n 1   6.9    0.7 grass      \n 2  13      1   grass      \n 3 100      2   grass      \n 4   8.5    0.6 fire       \n 5  19      1.1 fire       \n 6  90.5    1.7 fire       \n 7   9      0.5 water      \n 8  22.5    1   water      \n 9  85.5    1.6 water      \n10   2.9    0.3 bug        \n# ℹ 939 more rows\n```\n:::\n:::\n\n\n::: callout-tip\nLa función `select()` también entrega la posibilidad de renombrar variables, lo que puede reducir el código presentado anteriormente.\n:::\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata_poke |> \n  select(peso = weight,\n         altura = height,\n         primer_tipo = type_1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 949 × 3\n    peso altura primer_tipo\n   <dbl>  <dbl> <chr>      \n 1   6.9    0.7 grass      \n 2  13      1   grass      \n 3 100      2   grass      \n 4   8.5    0.6 fire       \n 5  19      1.1 fire       \n 6  90.5    1.7 fire       \n 7   9      0.5 water      \n 8  22.5    1   water      \n 9  85.5    1.6 water      \n10   2.9    0.3 bug        \n# ℹ 939 more rows\n```\n:::\n:::\n\n\n### Usando vectores\n\nEs posible definir un vector y aplicar la función `all_of()` o `any_of()`revisados anteriormente.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnuevos_nombres <- c(id_pokemon = \"id\", id_especies = \"species_id\", \n                    altura = \"height\", peso = \"weight\", \n                    exp_base = \"base_experience\", \n                    tipo_1 = \"type_1\", tipo_2 = \"type_2\")\n\ndata_poke |> \n  rename(all_of(nuevos_nombres))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 949 × 22\n   id_pokemon pokemon    id_especies altura  peso exp_base tipo_1 tipo_2    hp\n        <dbl> <chr>            <dbl>  <dbl> <dbl>    <dbl> <chr>  <chr>  <dbl>\n 1          1 bulbasaur            1    0.7   6.9       64 grass  poison    45\n 2          2 ivysaur              2    1    13        142 grass  poison    60\n 3          3 venusaur             3    2   100        236 grass  poison    80\n 4          4 charmander           4    0.6   8.5       62 fire   <NA>      39\n 5          5 charmeleon           5    1.1  19        142 fire   <NA>      58\n 6          6 charizard            6    1.7  90.5      240 fire   flying    78\n 7          7 squirtle             7    0.5   9         63 water  <NA>      44\n 8          8 wartortle            8    1    22.5      142 water  <NA>      59\n 9          9 blastoise            9    1.6  85.5      239 water  <NA>      79\n10         10 caterpie            10    0.3   2.9       39 bug    <NA>      45\n# ℹ 939 more rows\n# ℹ 13 more variables: attack <dbl>, defense <dbl>, special_attack <dbl>,\n#   special_defense <dbl>, speed <dbl>, color_1 <chr>, color_2 <chr>,\n#   color_f <chr>, egg_group_1 <chr>, egg_group_2 <chr>, url_icon <chr>,\n#   generation_id <dbl>, url_image <chr>\n```\n:::\n:::\n\n\n### Aplicando funciones\n\nA veces necesitaremos realizar una transformación masiva en los nombres de la base de datos. En ese caso, la mejor opción es usar `rename_with()` junto a la función indicada.\n\nEn el siguiente ejemplo, cambiaremos todos los guiones bajos de los nombres por un punto. Para ello emplearemos la función `str_replace()` del paquete `stringr`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata_poke |> \n  rename_with(~str_replace(.x, \"_\", \".\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 949 × 22\n      id pokemon    species.id height weight base.experience type.1 type.2    hp\n   <dbl> <chr>           <dbl>  <dbl>  <dbl>           <dbl> <chr>  <chr>  <dbl>\n 1     1 bulbasaur           1    0.7    6.9              64 grass  poison    45\n 2     2 ivysaur             2    1     13               142 grass  poison    60\n 3     3 venusaur            3    2    100               236 grass  poison    80\n 4     4 charmander          4    0.6    8.5              62 fire   <NA>      39\n 5     5 charmeleon          5    1.1   19               142 fire   <NA>      58\n 6     6 charizard           6    1.7   90.5             240 fire   flying    78\n 7     7 squirtle            7    0.5    9                63 water  <NA>      44\n 8     8 wartortle           8    1     22.5             142 water  <NA>      59\n 9     9 blastoise           9    1.6   85.5             239 water  <NA>      79\n10    10 caterpie           10    0.3    2.9              39 bug    <NA>      45\n# ℹ 939 more rows\n# ℹ 13 more variables: attack <dbl>, defense <dbl>, special.attack <dbl>,\n#   special.defense <dbl>, speed <dbl>, color.1 <chr>, color.2 <chr>,\n#   color.f <chr>, egg.group_1 <chr>, egg.group_2 <chr>, url.icon <chr>,\n#   generation.id <dbl>, url.image <chr>\n```\n:::\n:::\n\n\n## relocate\n\nEsta función simplemente cambia la posición de las columnas, para lo cual se le indican los nombres de las columnas que desea. Adicionalmente cuenta con los argumentos `.after` y `.before` para indicar después o antes de qué columna irán las especificadas.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata_poke |> \n  relocate(generation_id, .after = pokemon)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 949 × 22\n      id pokemon   generation_id species_id height weight base_experience type_1\n   <dbl> <chr>             <dbl>      <dbl>  <dbl>  <dbl>           <dbl> <chr> \n 1     1 bulbasaur             1          1    0.7    6.9              64 grass \n 2     2 ivysaur               1          2    1     13               142 grass \n 3     3 venusaur              1          3    2    100               236 grass \n 4     4 charmand…             1          4    0.6    8.5              62 fire  \n 5     5 charmele…             1          5    1.1   19               142 fire  \n 6     6 charizard             1          6    1.7   90.5             240 fire  \n 7     7 squirtle              1          7    0.5    9                63 water \n 8     8 wartortle             1          8    1     22.5             142 water \n 9     9 blastoise             1          9    1.6   85.5             239 water \n10    10 caterpie              1         10    0.3    2.9              39 bug   \n# ℹ 939 more rows\n# ℹ 14 more variables: type_2 <chr>, hp <dbl>, attack <dbl>, defense <dbl>,\n#   special_attack <dbl>, special_defense <dbl>, speed <dbl>, color_1 <chr>,\n#   color_2 <chr>, color_f <chr>, egg_group_1 <chr>, egg_group_2 <chr>,\n#   url_icon <chr>, url_image <chr>\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ndata_poke |> \n  relocate(generation_id, .before = pokemon)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 949 × 22\n      id generation_id pokemon   species_id height weight base_experience type_1\n   <dbl>         <dbl> <chr>          <dbl>  <dbl>  <dbl>           <dbl> <chr> \n 1     1             1 bulbasaur          1    0.7    6.9              64 grass \n 2     2             1 ivysaur            2    1     13               142 grass \n 3     3             1 venusaur           3    2    100               236 grass \n 4     4             1 charmand…          4    0.6    8.5              62 fire  \n 5     5             1 charmele…          5    1.1   19               142 fire  \n 6     6             1 charizard          6    1.7   90.5             240 fire  \n 7     7             1 squirtle           7    0.5    9                63 water \n 8     8             1 wartortle          8    1     22.5             142 water \n 9     9             1 blastoise          9    1.6   85.5             239 water \n10    10             1 caterpie          10    0.3    2.9              39 bug   \n# ℹ 939 more rows\n# ℹ 14 more variables: type_2 <chr>, hp <dbl>, attack <dbl>, defense <dbl>,\n#   special_attack <dbl>, special_defense <dbl>, speed <dbl>, color_1 <chr>,\n#   color_2 <chr>, color_f <chr>, egg_group_1 <chr>, egg_group_2 <chr>,\n#   url_icon <chr>, url_image <chr>\n```\n:::\n:::\n\n\nY de igual forma, se pueden usar las funciones de `tidyselect`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata_poke |> \n  relocate(generation_id, .before = starts_with(\"type\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 949 × 22\n      id pokemon   species_id height weight base_experience generation_id type_1\n   <dbl> <chr>          <dbl>  <dbl>  <dbl>           <dbl>         <dbl> <chr> \n 1     1 bulbasaur          1    0.7    6.9              64             1 grass \n 2     2 ivysaur            2    1     13               142             1 grass \n 3     3 venusaur           3    2    100               236             1 grass \n 4     4 charmand…          4    0.6    8.5              62             1 fire  \n 5     5 charmele…          5    1.1   19               142             1 fire  \n 6     6 charizard          6    1.7   90.5             240             1 fire  \n 7     7 squirtle           7    0.5    9                63             1 water \n 8     8 wartortle          8    1     22.5             142             1 water \n 9     9 blastoise          9    1.6   85.5             239             1 water \n10    10 caterpie          10    0.3    2.9              39             1 bug   \n# ℹ 939 more rows\n# ℹ 14 more variables: type_2 <chr>, hp <dbl>, attack <dbl>, defense <dbl>,\n#   special_attack <dbl>, special_defense <dbl>, speed <dbl>, color_1 <chr>,\n#   color_2 <chr>, color_f <chr>, egg_group_1 <chr>, egg_group_2 <chr>,\n#   url_icon <chr>, url_image <chr>\n```\n:::\n:::\n\n\n## filter\n\nPermite obtener un subconjunto de observaciones a partir de las condiciones lógicas especificadas.Estas condiciones lógicas están definidas por el lenguaje de programación.\n\nCabe mencionar que es imperativo manejar estas condiciones, pues se utilizan en múltiples etapas del procesamiento y análisis de datos.\n\n| Símbolo | Definición                                                                                          |\n|----------------|--------------------------------------------------------|\n| ==      | **Igualdad**. No debe confundirse con \"=\", que es un operador de asignación                         |\n| !=      | **Distinto**                                                                                        |\n| !       | **Negación** de una expresión lógica                                                                |\n| \\>      | **Mayor que**                                                                                       |\n| \\<      | **Menor que**                                                                                       |\n| \\>=     | **Mayor o igual que**                                                                               |\n| \\<=     | **Menor o igual que**                                                                               |\n| %in%    | Operador de R que indica un **conjunto de elementos**                                               |\n| &       | Operador **\"y\"**. Todas las condiciones evaluadas deben ser verdaderas para que la expresión lo sea |\n| \\|      | Operador **\"o\"**. Al menos una condición debe ser verdadera para que la expresión lo sea            |\n\n: Condiciones lógicas en R {#tbl-cond_logicas}\n\nEn los siguientes códigos se muestran una serie de ejemplos de aplicaciones de filtros.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Respetar mayúsculas y minúsculas\n# Selecciona todos los type_1 fuego\ndata_poke |> \n  filter(type_1 == \"fire\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 59 × 22\n      id pokemon    species_id height weight base_experience type_1 type_2    hp\n   <dbl> <chr>           <dbl>  <dbl>  <dbl>           <dbl> <chr>  <chr>  <dbl>\n 1     4 charmander          4    0.6    8.5              62 fire   <NA>      39\n 2     5 charmeleon          5    1.1   19               142 fire   <NA>      58\n 3     6 charizard           6    1.7   90.5             240 fire   flying    78\n 4    37 vulpix             37    0.6    9.9              60 fire   <NA>      38\n 5    38 ninetales          38    1.1   19.9             177 fire   <NA>      73\n 6    58 growlithe          58    0.7   19                70 fire   <NA>      55\n 7    59 arcanine           59    1.9  155               194 fire   <NA>      90\n 8    77 ponyta             77    1     30                82 fire   <NA>      50\n 9    78 rapidash           78    1.7   95               175 fire   <NA>      65\n10   126 magmar            126    1.3   44.5             173 fire   <NA>      65\n# ℹ 49 more rows\n# ℹ 13 more variables: attack <dbl>, defense <dbl>, special_attack <dbl>,\n#   special_defense <dbl>, speed <dbl>, color_1 <chr>, color_2 <chr>,\n#   color_f <chr>, egg_group_1 <chr>, egg_group_2 <chr>, url_icon <chr>,\n#   generation_id <dbl>, url_image <chr>\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Selecciona todos los que no sean fuego en type_1\ndata_poke |> \n  filter(type_1 != \"fire\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 890 × 22\n      id pokemon    species_id height weight base_experience type_1 type_2    hp\n   <dbl> <chr>           <dbl>  <dbl>  <dbl>           <dbl> <chr>  <chr>  <dbl>\n 1     1 bulbasaur           1    0.7    6.9              64 grass  poison    45\n 2     2 ivysaur             2    1     13               142 grass  poison    60\n 3     3 venusaur            3    2    100               236 grass  poison    80\n 4     7 squirtle            7    0.5    9                63 water  <NA>      44\n 5     8 wartortle           8    1     22.5             142 water  <NA>      59\n 6     9 blastoise           9    1.6   85.5             239 water  <NA>      79\n 7    10 caterpie           10    0.3    2.9              39 bug    <NA>      45\n 8    11 metapod            11    0.7    9.9              72 bug    <NA>      50\n 9    12 butterfree         12    1.1   32               178 bug    flying    60\n10    13 weedle             13    0.3    3.2              39 bug    poison    40\n# ℹ 880 more rows\n# ℹ 13 more variables: attack <dbl>, defense <dbl>, special_attack <dbl>,\n#   special_defense <dbl>, speed <dbl>, color_1 <chr>, color_2 <chr>,\n#   color_f <chr>, egg_group_1 <chr>, egg_group_2 <chr>, url_icon <chr>,\n#   generation_id <dbl>, url_image <chr>\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Selecciona cualquiera que sea ghost o steel en type_1\ndata_poke |> \n  filter(type_1 %in% c(\"ghost\", \"steel\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 70 × 22\n      id pokemon    species_id height weight base_experience type_1 type_2    hp\n   <dbl> <chr>           <dbl>  <dbl>  <dbl>           <dbl> <chr>  <chr>  <dbl>\n 1    92 gastly             92    1.3    0.1              62 ghost  poison    30\n 2    93 haunter            93    1.6    0.1             142 ghost  poison    45\n 3    94 gengar             94    1.5   40.5             225 ghost  poison    60\n 4   200 misdreavus        200    0.7    1                87 ghost  <NA>      60\n 5   208 steelix           208    9.2  400               179 steel  ground    75\n 6   227 skarmory          227    1.7   50.5             163 steel  flying    65\n 7   303 mawile            303    0.6   11.5             133 steel  fairy     50\n 8   304 aron              304    0.4   60                66 steel  rock      50\n 9   305 lairon            305    0.9  120               151 steel  rock      60\n10   306 aggron            306    2.1  360               239 steel  rock      70\n# ℹ 60 more rows\n# ℹ 13 more variables: attack <dbl>, defense <dbl>, special_attack <dbl>,\n#   special_defense <dbl>, speed <dbl>, color_1 <chr>, color_2 <chr>,\n#   color_f <chr>, egg_group_1 <chr>, egg_group_2 <chr>, url_icon <chr>,\n#   generation_id <dbl>, url_image <chr>\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Selecciona cualquiera que no sea agua, hierba o fuego en type_1\ndata_poke |> \n  filter(!(type_1 %in% c(\"grass\", \"fire\", \"water\")))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 680 × 22\n      id pokemon    species_id height weight base_experience type_1 type_2    hp\n   <dbl> <chr>           <dbl>  <dbl>  <dbl>           <dbl> <chr>  <chr>  <dbl>\n 1    10 caterpie           10    0.3    2.9              39 bug    <NA>      45\n 2    11 metapod            11    0.7    9.9              72 bug    <NA>      50\n 3    12 butterfree         12    1.1   32               178 bug    flying    60\n 4    13 weedle             13    0.3    3.2              39 bug    poison    40\n 5    14 kakuna             14    0.6   10                72 bug    poison    45\n 6    15 beedrill           15    1     29.5             178 bug    poison    65\n 7    16 pidgey             16    0.3    1.8              50 normal flying    40\n 8    17 pidgeotto          17    1.1   30               122 normal flying    63\n 9    18 pidgeot            18    1.5   39.5             216 normal flying    83\n10    19 rattata            19    0.3    3.5              51 normal <NA>      30\n# ℹ 670 more rows\n# ℹ 13 more variables: attack <dbl>, defense <dbl>, special_attack <dbl>,\n#   special_defense <dbl>, speed <dbl>, color_1 <chr>, color_2 <chr>,\n#   color_f <chr>, egg_group_1 <chr>, egg_group_2 <chr>, url_icon <chr>,\n#   generation_id <dbl>, url_image <chr>\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Selecciona tipo hierba en type_1 de segunda generación\ndata_poke |> \n  filter(type_1 == \"grass\" & generation_id == 2) \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 9 × 22\n     id pokemon   species_id height weight base_experience type_1 type_2    hp\n  <dbl> <chr>          <dbl>  <dbl>  <dbl>           <dbl> <chr>  <chr>  <dbl>\n1   152 chikorita        152    0.9    6.4              64 grass  <NA>      45\n2   153 bayleef          153    1.2   15.8             142 grass  <NA>      60\n3   154 meganium         154    1.8  100.              236 grass  <NA>      80\n4   182 bellossom        182    0.4    5.8             221 grass  <NA>      75\n5   187 hoppip           187    0.4    0.5              50 grass  flying    35\n6   188 skiploom         188    0.6    1               119 grass  flying    55\n7   189 jumpluff         189    0.8    3               207 grass  flying    75\n8   191 sunkern          191    0.3    1.8              36 grass  <NA>      30\n9   192 sunflora         192    0.8    8.5             149 grass  <NA>      75\n# ℹ 13 more variables: attack <dbl>, defense <dbl>, special_attack <dbl>,\n#   special_defense <dbl>, speed <dbl>, color_1 <chr>, color_2 <chr>,\n#   color_f <chr>, egg_group_1 <chr>, egg_group_2 <chr>, url_icon <chr>,\n#   generation_id <dbl>, url_image <chr>\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Selecciona tipo hielo en type_1 o type_2\ndata_poke |> \n  filter(type_1 == \"ice\" | type_2 == \"ice\") \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 44 × 22\n      id pokemon   species_id height weight base_experience type_1 type_2     hp\n   <dbl> <chr>          <dbl>  <dbl>  <dbl>           <dbl> <chr>  <chr>   <dbl>\n 1    87 dewgong           87    1.7  120               166 water  ice        90\n 2    91 cloyster          91    1.5  132.              184 water  ice        50\n 3   124 jynx             124    1.4   40.6             159 ice    psychic    65\n 4   131 lapras           131    2.5  220               187 water  ice       130\n 5   144 articuno         144    1.7   55.4             261 ice    flying     90\n 6   215 sneasel          215    0.9   28                86 dark   ice        55\n 7   220 swinub           220    0.4    6.5              50 ice    ground     50\n 8   221 piloswine        221    1.1   55.8             158 ice    ground    100\n 9   225 delibird         225    0.9   16               116 ice    flying     45\n10   238 smoochum         238    0.4    6                61 ice    psychic    45\n# ℹ 34 more rows\n# ℹ 13 more variables: attack <dbl>, defense <dbl>, special_attack <dbl>,\n#   special_defense <dbl>, speed <dbl>, color_1 <chr>, color_2 <chr>,\n#   color_f <chr>, egg_group_1 <chr>, egg_group_2 <chr>, url_icon <chr>,\n#   generation_id <dbl>, url_image <chr>\n```\n:::\n:::\n\n\nCon las funciones de `stringr` se pueden realizar filtros más específicos para variables de tipo `character`. Por ejemplo, en el siguiente filtro se seleccionan todas los pokémon cuyo nombre finalice en `chu`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Selecciona pokémon terminados en \"on\"\ndata_poke |> \n  filter(str_ends(pokemon, \"chu\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 3 × 22\n     id pokemon species_id height weight base_experience type_1   type_2    hp\n  <dbl> <chr>        <dbl>  <dbl>  <dbl>           <dbl> <chr>    <chr>  <dbl>\n1    25 pikachu         25    0.4      6             112 electric <NA>      35\n2    26 raichu          26    0.8     30             218 electric <NA>      60\n3   172 pichu          172    0.3      2              41 electric <NA>      20\n# ℹ 13 more variables: attack <dbl>, defense <dbl>, special_attack <dbl>,\n#   special_defense <dbl>, speed <dbl>, color_1 <chr>, color_2 <chr>,\n#   color_f <chr>, egg_group_1 <chr>, egg_group_2 <chr>, url_icon <chr>,\n#   generation_id <dbl>, url_image <chr>\n```\n:::\n:::\n\n\n## arrange\n\nEs una función que ermite ordenar las filas a partir de valores de las columnas. Por defecto lo realizará de manera ascendente.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Ascendente\ndata_poke |> \n  arrange(attack) |> \n  select(pokemon, attack)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 949 × 2\n   pokemon  attack\n   <chr>     <dbl>\n 1 chansey       5\n 2 happiny       5\n 3 magikarp     10\n 4 shuckle      10\n 5 blissey      10\n 6 feebas       15\n 7 metapod      20\n 8 abra         20\n 9 ledyba       20\n10 togepi       20\n# ℹ 939 more rows\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Por tipo y luego descendente por ataque\ndata_poke |> \n  arrange(type_1, desc(attack)) |> \n  select(pokemon, type_1, attack)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 949 × 3\n   pokemon        type_1 attack\n   <chr>          <chr>   <dbl>\n 1 heracross-mega bug       185\n 2 pinsir-mega    bug       155\n 3 scizor-mega    bug       150\n 4 beedrill-mega  bug       150\n 5 buzzwole       bug       139\n 6 pheromosa      bug       137\n 7 escavalier     bug       135\n 8 scizor         bug       130\n 9 pinsir         bug       125\n10 heracross      bug       125\n# ℹ 939 more rows\n```\n:::\n:::\n\n\n## slice\n\nPosibilita seleccionar filas a partir de su posición. Esta selección se puede realizar\n\n-   A partir de valores únicos o rangos utilizando dos puntos `:`.\n-   Excluyendo posiciones o rango de posiciones empleando el símbolo menos `-`.\n-   Seleccionar observaciones desde el principio o final con `slice_head()` y `slice_tail()`, respectivamente.\n-   Seleccionar muestras aleatorias de casos, ya sea a partir de números o porcentajes, con los argumentos `n` y `prop` según corresponda.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata_poke |> slice(150)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1 × 22\n     id pokemon species_id height weight base_experience type_1  type_2    hp\n  <dbl> <chr>        <dbl>  <dbl>  <dbl>           <dbl> <chr>   <chr>  <dbl>\n1   150 mewtwo         150      2    122             306 psychic <NA>     106\n# ℹ 13 more variables: attack <dbl>, defense <dbl>, special_attack <dbl>,\n#   special_defense <dbl>, speed <dbl>, color_1 <chr>, color_2 <chr>,\n#   color_f <chr>, egg_group_1 <chr>, egg_group_2 <chr>, url_icon <chr>,\n#   generation_id <dbl>, url_image <chr>\n```\n:::\n\n```{.r .cell-code}\ndata_poke |> slice(236:240)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 5 × 22\n     id pokemon   species_id height weight base_experience type_1   type_2    hp\n  <dbl> <chr>          <dbl>  <dbl>  <dbl>           <dbl> <chr>    <chr>  <dbl>\n1   236 tyrogue          236    0.7   21                42 fighting <NA>      35\n2   237 hitmontop        237    1.4   48               159 fighting <NA>      50\n3   238 smoochum         238    0.4    6                61 ice      psych…    45\n4   239 elekid           239    0.6   23.5              72 electric <NA>      45\n5   240 magby            240    0.7   21.4              73 fire     <NA>      45\n# ℹ 13 more variables: attack <dbl>, defense <dbl>, special_attack <dbl>,\n#   special_defense <dbl>, speed <dbl>, color_1 <chr>, color_2 <chr>,\n#   color_f <chr>, egg_group_1 <chr>, egg_group_2 <chr>, url_icon <chr>,\n#   generation_id <dbl>, url_image <chr>\n```\n:::\n\n```{.r .cell-code}\n# Partiendo desde el principio, los 5 primeros\ndata_poke |> slice_head(n = 5)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 5 × 22\n     id pokemon    species_id height weight base_experience type_1 type_2    hp\n  <dbl> <chr>           <dbl>  <dbl>  <dbl>           <dbl> <chr>  <chr>  <dbl>\n1     1 bulbasaur           1    0.7    6.9              64 grass  poison    45\n2     2 ivysaur             2    1     13               142 grass  poison    60\n3     3 venusaur            3    2    100               236 grass  poison    80\n4     4 charmander          4    0.6    8.5              62 fire   <NA>      39\n5     5 charmeleon          5    1.1   19               142 fire   <NA>      58\n# ℹ 13 more variables: attack <dbl>, defense <dbl>, special_attack <dbl>,\n#   special_defense <dbl>, speed <dbl>, color_1 <chr>, color_2 <chr>,\n#   color_f <chr>, egg_group_1 <chr>, egg_group_2 <chr>, url_icon <chr>,\n#   generation_id <dbl>, url_image <chr>\n```\n:::\n\n```{.r .cell-code}\n# Partiendo desde el final, los 5 primeros\ndata_poke |> slice_tail(n = 5)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 5 × 22\n     id pokemon     species_id height weight base_experience type_1 type_2    hp\n  <dbl> <chr>            <dbl>  <dbl>  <dbl>           <dbl> <chr>  <chr>  <dbl>\n1 10143 mimikyu-bu…        778    0.2    0.7             167 ghost  fairy     55\n2 10144 mimikyu-to…        778    0.4    2.8             167 ghost  fairy     55\n3 10145 mimikyu-to…        778    0.4    2.8             167 ghost  fairy     55\n4 10146 kommo-o-to…        784    2.4  208.              270 dragon fight…    75\n5 10147 magearna-o…        801    1     80.5             120 steel  fairy     80\n# ℹ 13 more variables: attack <dbl>, defense <dbl>, special_attack <dbl>,\n#   special_defense <dbl>, speed <dbl>, color_1 <chr>, color_2 <chr>,\n#   color_f <chr>, egg_group_1 <chr>, egg_group_2 <chr>, url_icon <chr>,\n#   generation_id <dbl>, url_image <chr>\n```\n:::\n\n```{.r .cell-code}\nset.seed(1234)\n# Muestra aleatoria de 7 casos\ndata_poke |> slice_sample(n = 7)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 7 × 22\n     id pokemon     species_id height weight base_experience type_1 type_2    hp\n  <dbl> <chr>            <dbl>  <dbl>  <dbl>           <dbl> <chr>  <chr>  <dbl>\n1   284 masquerain         284    0.8    3.6             159 bug    flying    70\n2 10046 scizor-mega        212    2    125               210 bug    steel     70\n3 10116 greninja-b…        658    1.5   40               239 water  dark      72\n4   101 electrode          101    1.2   66.6             172 elect… <NA>      60\n5   623 golurk             623    2.8  330               169 ground ghost     89\n6 10103 vulpix-alo…         37    0.6    9.9              60 ice    <NA>      38\n7   645 landorus-i…        645    1.5   68               270 ground flying    89\n# ℹ 13 more variables: attack <dbl>, defense <dbl>, special_attack <dbl>,\n#   special_defense <dbl>, speed <dbl>, color_1 <chr>, color_2 <chr>,\n#   color_f <chr>, egg_group_1 <chr>, egg_group_2 <chr>, url_icon <chr>,\n#   generation_id <dbl>, url_image <chr>\n```\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}