{
  "hash": "13340c7dc7b50a661bfb9c54dcc50873",
  "result": {
    "markdown": "---\n# Título y Autor\ntitle: \"Notas clase 2: Tipos y Estructuras de datos en R\"\nsubtitle: |\n    | Curso: Metodología Cuantitativa.\n    | Magíster en Trabajo Social, Pontificia Universidad Católica de Chile.\nauthor: \"Sebastián Rojas Vergara\"\n# date: \n# abstract: \n# thanks:\n# order: \n# Opciones de formato\nformat: \n  html:\n    # Fuente\n    # Despliegue de código\n    code-fold: false\n    code-line-numbers: true\n    # Tema\n    theme:\n      light: flatly\n      dark: darkly\n    highlight-style: haddock\n    # Autocontenido\n    self-contained: true\n    # estilos\n    css: styles.css\n# Tabla de contenidos\ntoc: true\ntoc-depth: 4\ntoc-location: right\n# Numeración\nnumber-sections: true\n# Figuras\nfig-align: center\nfig-cap-location: top\n# Notas al pie\nfootnotes-hover: true\n# Lenguaje\nlang: \"es\"\n# Ejecución de código\ncomments: false\nexecute: \n  echo: true\n---\n\n\n<img src=\"images/logo_puc_bn.png\" alt=\"Logo PUC\" style=\"position: fixed; top: 0; right: 0; width: 150px; height: 90px;\">\n\n\n## Introducción{.unnumbered}\n\nLos dataframes y tibbles son estructuras de datos en que cada columna o variable corresponde a un vector, estos últimos siempre conteniendo un solo tipo de dato. Esto permite aplicar funciones que están disponibles para los vectores.\n\nSi bien hay funciones que son comunes independiente del tipo de vector, hay otras que están disponibles según sea el tipo de dato. Por ejemplo, funciones para vectores `numeric`, `character`, `factor`, etc.\n  \n::: {.callout-note}\nLas funciones que se presentan a continuación son las disponibles en R \"base\", es decir, aquellas nativas del lenguaje. En las próximas sesiones se verán las funciones disponibles a través del paquete `tidyverse`. \n\nHay al menos dos razones por las que es necesario conocer sobre las funciones de R base.\n\n 1. Hay conceptos y funciones de R base que son transversales, independiente del paquete que estemos usando.\n 2. Durante nuestro trabajo nos puede interactuar con personas que conozcan solo R base o realicen operaciones mezclando R base junto con otras librerías.\n \nCabe mencionar que el listado que se presenta a continuación no es exhaustivo. La cantidad de funciones disponibles en R base supera ampliamente los alcances de este curso.\n:::  \n  \n## Conjunto de datos\n\nUsaremos la función `tibble()` del paquete `tibble`, que forma parte de `tidyverse`. Esto también podría haberse realizado usando la función `data.frame()`, el cual es nativo de R.\n\n::: {.callout-tip}\nEn R es posible llamar a un paquete sin la necesidad de cargarlo con `library()`. Para ello, se debe escribir el nombre del paquete, seguido dos puntos `:` y luego se especifica la función de ese paquete que se desea llamar `paquete::funcion`.\n\nEn el código que se presenta más adelante, se está llamando del paquete `tibble` a la función `tibble()`. Algunos elementos que se debe tener en cuenta:\n\n - Es útil cuando queremos acceder a una función de un paquete por una o pocas veces, sin la necesidad de cargarlo.\n - Hay paquetes que pueden tener funciones con el mismo nombre, lo que genera ciertos conflictos. Especificar directamente el paquete desde el cual se está llamando a esa función evita o disminuye ese problema (que de igual forma tiene solución). \n - Si el paquete no está cargado, el llamado se debe hacer cada vez que se desee usar una de sus funciones.\n:::  \n\nCrearemos un conjunto de datos de estudiantes de talleres de música con la siguiente información. \n\n - **nombre**: primer nombre.\n - **apellido**: primer apellido.\n - **edad**: edad en años.\n - **ppa**: promedio ponderado acumulado.\n - **pais**: país de nacionalidad del estudiante. \n \n\n::: {.cell}\n\n```{.r .cell-code}\nestudiantes <- tibble::tibble(\n  nombre = c(\"Ismael\", \"Andrea\", \"Ernesto\",\n             \"Daniela\", \"David\", \"Magdalena\",\n             \"Santiago\"),\n  apellido = c(\"Fernández\", \"Pérez\", \"Leal\",\n               \"Núñez\", \"Espinoza\", \"Madrid\",\n               \"Vergara\"),\n  edad = c(29, 45, 79,\n           18, 63, 80,\n           35),\n  ppa = c(5.75, 6.12, 5.06,\n          6.12, 4.73, 5.24,\n          4.94),\n  region = c(\"Región Metropolitana\", \"Región de La Araucanía\", \n             \"Región de Arica y Parinacota\", \"Región de Valparaíso\", \n             \"Región Metropolitana\", \"Región del Ñuble\",\n             \"Región del Maule\"),\n  pais = c(\"Chile\") \n  # Como solo hay un único valor, R lo recicla para asigarlo a todos.\n  )\nestudiantes\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 7 × 6\n  nombre    apellido   edad   ppa region                       pais \n  <chr>     <chr>     <dbl> <dbl> <chr>                        <chr>\n1 Ismael    Fernández    29  5.75 Región Metropolitana         Chile\n2 Andrea    Pérez        45  6.12 Región de La Araucanía       Chile\n3 Ernesto   Leal         79  5.06 Región de Arica y Parinacota Chile\n4 Daniela   Núñez        18  6.12 Región de Valparaíso         Chile\n5 David     Espinoza     63  4.73 Región Metropolitana         Chile\n6 Magdalena Madrid       80  5.24 Región del Ñuble             Chile\n7 Santiago  Vergara      35  4.94 Región del Maule             Chile\n```\n:::\n:::\n\n\n## Explorar\n\nLas siguientes funciones permiten explorar un conjunto de datos:\n\n- `dim()`: muestra las dimensiones, es decir, el número de filas y columnas. Si se desea saber solamente las filas o columnas, se puede emplear `nrow` o `ncol` respectivamente.\n- `str()`: muestra la estructrura del conjunto de datos.\n- `names()`: muestra los nombres de las columnas.\n- `summary()`: entrega estadísticas de resumen para cada columna. \n- `head()`: muestra las primeras n filas. Con el argumento `x` se puede especificar el número de filas. Si no se indica, mostrará 6.\n- `tail()`: muestra las últimas n filas. Con el argumento `x` se puede especificar el número de filas. Si no se indica, mostrará 6.\n- `View()`: muestra el conjunto de datos en otra ventana.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndim(estudiantes) \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 7 6\n```\n:::\n\n```{.r .cell-code}\nstr(estudiantes)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\ntibble [7 × 6] (S3: tbl_df/tbl/data.frame)\n $ nombre  : chr [1:7] \"Ismael\" \"Andrea\" \"Ernesto\" \"Daniela\" ...\n $ apellido: chr [1:7] \"Fernández\" \"Pérez\" \"Leal\" \"Núñez\" ...\n $ edad    : num [1:7] 29 45 79 18 63 80 35\n $ ppa     : num [1:7] 5.75 6.12 5.06 6.12 4.73 5.24 4.94\n $ region  : chr [1:7] \"Región Metropolitana\" \"Región de La Araucanía\" \"Región de Arica y Parinacota\" \"Región de Valparaíso\" ...\n $ pais    : chr [1:7] \"Chile\" \"Chile\" \"Chile\" \"Chile\" ...\n```\n:::\n\n```{.r .cell-code}\nnames(estudiantes)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"nombre\"   \"apellido\" \"edad\"     \"ppa\"      \"region\"   \"pais\"    \n```\n:::\n\n```{.r .cell-code}\nsummary(estudiantes)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n    nombre            apellido              edad            ppa       \n Length:7           Length:7           Min.   :18.00   Min.   :4.730  \n Class :character   Class :character   1st Qu.:32.00   1st Qu.:5.000  \n Mode  :character   Mode  :character   Median :45.00   Median :5.240  \n                                       Mean   :49.86   Mean   :5.423  \n                                       3rd Qu.:71.00   3rd Qu.:5.935  \n                                       Max.   :80.00   Max.   :6.120  \n    region              pais          \n Length:7           Length:7          \n Class :character   Class :character  \n Mode  :character   Mode  :character  \n                                      \n                                      \n                                      \n```\n:::\n\n```{.r .cell-code}\nhead(estudiantes, n = 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 2 × 6\n  nombre apellido   edad   ppa region                 pais \n  <chr>  <chr>     <dbl> <dbl> <chr>                  <chr>\n1 Ismael Fernández    29  5.75 Región Metropolitana   Chile\n2 Andrea Pérez        45  6.12 Región de La Araucanía Chile\n```\n:::\n\n```{.r .cell-code}\ntail(estudiantes, n = 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 2 × 6\n  nombre    apellido  edad   ppa region           pais \n  <chr>     <chr>    <dbl> <dbl> <chr>            <chr>\n1 Magdalena Madrid      80  5.24 Región del Ñuble Chile\n2 Santiago  Vergara     35  4.94 Región del Maule Chile\n```\n:::\n:::\n\n\n## Procesar\n\n### Crear, modificar o eliminar variables\n\nPara eliminar variables existen múltiples modos. Veremos dos:\n\n 1. Usando la función `subset()`, que retorna un subconjunto de datos a partir de una selección. Esta tiene un argumento llamado `select` que permite indicar columnas. Las columnas también se pueden indicar en sentido negativo usando el signo menos `-` (i.e. todas menos las indicadas con signo negativo).\n \n 2. Accediendo a través del nombre de las variables usando la notación `[]`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Forma 1\nestudiantes <- subset(estudiantes, select = -pais)\nestudiantes\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 7 × 5\n  nombre    apellido   edad   ppa region                      \n  <chr>     <chr>     <dbl> <dbl> <chr>                       \n1 Ismael    Fernández    29  5.75 Región Metropolitana        \n2 Andrea    Pérez        45  6.12 Región de La Araucanía      \n3 Ernesto   Leal         79  5.06 Región de Arica y Parinacota\n4 Daniela   Núñez        18  6.12 Región de Valparaíso        \n5 David     Espinoza     63  4.73 Región Metropolitana        \n6 Magdalena Madrid       80  5.24 Región del Ñuble            \n7 Santiago  Vergara      35  4.94 Región del Maule            \n```\n:::\n:::\n\n\n::: {.callout-tip}\nEs importante notar que en el código de arriba se está sobreescribiendo el objeto estudiantes para que contenga la nueva información (i.e. el conjunto sin la columna país). Este proceso ocurre porque se está creando el objeto `estudiantes <-`, el cual ya existe.\n\n- Sobreescribir un objeto permite ahorrar memoria y guardar las operaciones realizadas.\n- En vez de sobreescribir, podría asignarse a un nuevo objeto. Por ejemplo: `estudiantes_1 <- subset(estudiantes, select = -pais)` crearía un objeto llamado `estudiantes_1` que contendría la operación realizada sobre `estudiantes`, pero sin modificar el original. \n:::\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Forma 2\nestudiantes[, names(estudiantes) != \"pais\"] # Accedemos a los nombres que no sean \"pais\"\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 7 × 5\n  nombre    apellido   edad   ppa region                      \n  <chr>     <chr>     <dbl> <dbl> <chr>                       \n1 Ismael    Fernández    29  5.75 Región Metropolitana        \n2 Andrea    Pérez        45  6.12 Región de La Araucanía      \n3 Ernesto   Leal         79  5.06 Región de Arica y Parinacota\n4 Daniela   Núñez        18  6.12 Región de Valparaíso        \n5 David     Espinoza     63  4.73 Región Metropolitana        \n6 Magdalena Madrid       80  5.24 Región del Ñuble            \n7 Santiago  Vergara      35  4.94 Región del Maule            \n```\n:::\n:::\n\n\nPara añadir o modificar variables hay múltiples formas. A continuación se presentan dos.\n\n 1. Usando el operador `$`.\n 2. Usando la notación `[]`.\n \nPara el conjunto de datos que ya teníamos se agregarán las siguientes variables:\n\n  - **serie_fav**: serie favorita indicada por la persona.\n  - **musica_fav**: género de música favorito indicado por la persona.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Forma 1\nestudiantes$serie_fav <- c(\"Game of Thrones\", \"Los Soprano\", \"Breaking Bad\",\n                           \"Breaking Bad\", \"Dark\", \"Los 80\", \"The Boys\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Forma 2\nestudiantes[\"musica_fav\"] <- c(\"Metal\", \"Reggeaton\", \"Trap\",\n                                \"Música Clásica\", \"Ranchera\", \"Pop\", \"Jazz\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Forma 2, pero creando a partir de una variable ya existente\n# Para sobreescribir, tendría que llamarla en la izquierda con el mismo nombre\nestudiantes[\"edad_mas_1\"] <- estudiantes$edad + 1\n```\n:::\n\nCon las modificaciones realizadas el dataframe quedaría así:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nestudiantes\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 7 × 8\n  nombre    apellido   edad   ppa region         serie_fav musica_fav edad_mas_1\n  <chr>     <chr>     <dbl> <dbl> <chr>          <chr>     <chr>           <dbl>\n1 Ismael    Fernández    29  5.75 Región Metrop… Game of … Metal              30\n2 Andrea    Pérez        45  6.12 Región de La … Los Sopr… Reggeaton          46\n3 Ernesto   Leal         79  5.06 Región de Ari… Breaking… Trap               80\n4 Daniela   Núñez        18  6.12 Región de Val… Breaking… Música Cl…         19\n5 David     Espinoza     63  4.73 Región Metrop… Dark      Ranchera           64\n6 Magdalena Madrid       80  5.24 Región del Ñu… Los 80    Pop                81\n7 Santiago  Vergara      35  4.94 Región del Ma… The Boys  Jazz               36\n```\n:::\n:::\n\n\n### Combinar archivos\n\nA veces se contará con dos o más conjuntos de datos que se requieren combinar. Algunos escenarios donde podría ocurrir esto son los siguientes:\n  \n  - Si se tienen más observaciones para un conjunto de datos ya existentes. En este ejemplo, si hubiera información para **más estudiantes**.\n  - Si se tiene más información para un conjunto de datos ya existente. Por ejemplo, si se obtuviera **más información** para los estudiantes.\n\nLas funciones más básicas de R base que permiten esto son las siguientes:\n\n- `rbind`: combina dataframes/tibbles a partir de columnas.\n- `cbind`: combina dataframes/tibbles a partir de columnas.\n\n::: {.callout-important}\nPara que estas operaciones funcionen los dos dataframes deben tener las mismas dimensiones. Si no existiera dato para algún caso, se debe rellenar con `NA`.\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Definimos otro dataframe que uniremos\nfilas <- tibble::tibble(\n  nombre = c(\"Pilar\", \"Julio\"),\n  apellido = c(\"Farías\", \"Martínez\"),\n  edad = c(52, NA),\n  ppa = c(6.5, 5.14),\n  region = c(\"Región de Antofagasta\", \"Región Metropolitana\"),\n  serie_fav = NA,\n  musica_fav = c(\"Trap\", \"Hip hop\"),\n  edad_mas_1 = edad + 1\n  )\n\nestudiantes <- rbind(estudiantes, filas)\nestudiantes\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 9 × 8\n  nombre    apellido   edad   ppa region         serie_fav musica_fav edad_mas_1\n  <chr>     <chr>     <dbl> <dbl> <chr>          <chr>     <chr>           <dbl>\n1 Ismael    Fernández    29  5.75 Región Metrop… Game of … Metal              30\n2 Andrea    Pérez        45  6.12 Región de La … Los Sopr… Reggeaton          46\n3 Ernesto   Leal         79  5.06 Región de Ari… Breaking… Trap               80\n4 Daniela   Núñez        18  6.12 Región de Val… Breaking… Música Cl…         19\n5 David     Espinoza     63  4.73 Región Metrop… Dark      Ranchera           64\n6 Magdalena Madrid       80  5.24 Región del Ñu… Los 80    Pop                81\n7 Santiago  Vergara      35  4.94 Región del Ma… The Boys  Jazz               36\n8 Pilar     Farías       52  6.5  Región de Ant… <NA>      Trap               53\n9 Julio     Martínez     NA  5.14 Región Metrop… <NA>      Hip hop            NA\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ncolumnas <- tibble::tibble(\n  carrera = c(\"Trabajo Social\",\n              \"Ingeniería\",\n              \"Construcción Civil\",\n              \"Sociología\",\n              \"Estadística\",\n              \"Ciencia de Datos\",\n              \"Odontología\",\n              \"Letras\",\n              NA))\n\nestudiantes <- cbind(estudiantes, columnas)\nestudiantes\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     nombre  apellido edad  ppa                       region       serie_fav\n1    Ismael Fernández   29 5.75         Región Metropolitana Game of Thrones\n2    Andrea     Pérez   45 6.12       Región de La Araucanía     Los Soprano\n3   Ernesto      Leal   79 5.06 Región de Arica y Parinacota    Breaking Bad\n4   Daniela     Núñez   18 6.12         Región de Valparaíso    Breaking Bad\n5     David  Espinoza   63 4.73         Región Metropolitana            Dark\n6 Magdalena    Madrid   80 5.24             Región del Ñuble          Los 80\n7  Santiago   Vergara   35 4.94             Región del Maule        The Boys\n8     Pilar    Farías   52 6.50        Región de Antofagasta            <NA>\n9     Julio  Martínez   NA 5.14         Región Metropolitana            <NA>\n      musica_fav edad_mas_1            carrera\n1          Metal         30     Trabajo Social\n2      Reggeaton         46         Ingeniería\n3           Trap         80 Construcción Civil\n4 Música Clásica         19         Sociología\n5       Ranchera         64        Estadística\n6            Pop         81   Ciencia de Datos\n7           Jazz         36        Odontología\n8           Trap         53             Letras\n9        Hip hop         NA               <NA>\n```\n:::\n:::\n\n### Ordenar dataframe\n\nLa función `order()` permite ordenar las columnas de un vector. Generalmente usaremos alguna variable para hacer esta operación. \n\n - En el caso de variables numéricas, el orden estará dado dado por su valor.\n - En el caso de las variables de tipo caracter, el orden por defecto será alfabético.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Dentro del paréntesis cuadrado lo que está antes de la coma opera sobre las filas\n# Luego, en la parte de las columnas no hay nada, pues se seleccionan todas\nestudiantes <- estudiantes[order(estudiantes$edad), ]\nestudiantes\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     nombre  apellido edad  ppa                       region       serie_fav\n4   Daniela     Núñez   18 6.12         Región de Valparaíso    Breaking Bad\n1    Ismael Fernández   29 5.75         Región Metropolitana Game of Thrones\n7  Santiago   Vergara   35 4.94             Región del Maule        The Boys\n2    Andrea     Pérez   45 6.12       Región de La Araucanía     Los Soprano\n8     Pilar    Farías   52 6.50        Región de Antofagasta            <NA>\n5     David  Espinoza   63 4.73         Región Metropolitana            Dark\n3   Ernesto      Leal   79 5.06 Región de Arica y Parinacota    Breaking Bad\n6 Magdalena    Madrid   80 5.24             Región del Ñuble          Los 80\n9     Julio  Martínez   NA 5.14         Región Metropolitana            <NA>\n      musica_fav edad_mas_1            carrera\n4 Música Clásica         19         Sociología\n1          Metal         30     Trabajo Social\n7           Jazz         36        Odontología\n2      Reggeaton         46         Ingeniería\n8           Trap         53             Letras\n5       Ranchera         64        Estadística\n3           Trap         80 Construcción Civil\n6            Pop         81   Ciencia de Datos\n9        Hip hop         NA               <NA>\n```\n:::\n:::\n\nSi se desea que la función `order()` opere de manera descendente, se puede especificar el argumento `decreasing` con valor `TRUE`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nestudiantes <- estudiantes[order(estudiantes$edad, decreasing = TRUE), ]\nestudiantes\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     nombre  apellido edad  ppa                       region       serie_fav\n6 Magdalena    Madrid   80 5.24             Región del Ñuble          Los 80\n3   Ernesto      Leal   79 5.06 Región de Arica y Parinacota    Breaking Bad\n5     David  Espinoza   63 4.73         Región Metropolitana            Dark\n8     Pilar    Farías   52 6.50        Región de Antofagasta            <NA>\n2    Andrea     Pérez   45 6.12       Región de La Araucanía     Los Soprano\n7  Santiago   Vergara   35 4.94             Región del Maule        The Boys\n1    Ismael Fernández   29 5.75         Región Metropolitana Game of Thrones\n4   Daniela     Núñez   18 6.12         Región de Valparaíso    Breaking Bad\n9     Julio  Martínez   NA 5.14         Región Metropolitana            <NA>\n      musica_fav edad_mas_1            carrera\n6            Pop         81   Ciencia de Datos\n3           Trap         80 Construcción Civil\n5       Ranchera         64        Estadística\n8           Trap         53             Letras\n2      Reggeaton         46         Ingeniería\n7           Jazz         36        Odontología\n1          Metal         30     Trabajo Social\n4 Música Clásica         19         Sociología\n9        Hip hop         NA               <NA>\n```\n:::\n:::\n\n\n## Variables tipo numéricas\n\nR cuenta con una serie de funciones para obtener estadísticas de nuestras columnas cuyo tipo de dato sea `numeric`. \n\n - `mean()`: retorna la media aritmética de la columna o variable.\n - `median()`: retorna el valor de la mediana para la columna o variable.\n - `var()`: retorna la varianza para la columna o variable.\n - `sd()`: retorna la desviación estándar para la columna o variable.\n - `min()`: devuelve el valor mínimo para la columna o variable.\n - `max()`: devuelve el valor máximo para la columna o variable.\n - `range()`: devuelve un vector que contiene el valor mínimo y máximo para la columna o variable. Para obtenerlo con valor único, se pueden restar o aplicar la función `diff()`.\n - `quantile()`: retorna el cuantil especificado para la variable o conjunto de datos, el cual se especifica con el argumento `probs`. Los cuantiles son valores que dividen los datos en partes iguales. Por ejemplo, el percentil 50, que corresponde a la mediana, nos dice el valor en que el 50% de los casos son menores o iguales que el percentil 50 y el 50% son mayores o iguales que el percentil 50. \n - `round()`: redondea a la cantidad de digitos especificada en el argumento `digits`. Por defecto lo hará al entero más cercano. Hasta los valores 0.5 redondea hasta abajo y partir de ese valor redondea hacia arriba.\n - `ceiling()`: devuelve el próximo valor entero del número elegido. Siempre devolverá el entero posterior, salvo cuando el valor sea exacto.\n - `trunc()`: elimina los decimales sin redondear. \n\n::: {.callout-warning}\n\nEn R existe una función `mode()`, pero esta devuelve el modo en que está almacenado un objeto (p.e. `numeric`). Más adelante veremos cómo obtener la moda en R.\n::: \n \n\n::: {.cell}\n\n```{.r .cell-code}\nmean(estudiantes$ppa)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 5.511111\n```\n:::\n\n```{.r .cell-code}\nmedian(estudiantes$ppa)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 5.24\n```\n:::\n\n```{.r .cell-code}\nvar(estudiantes$ppa)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.3909361\n```\n:::\n\n```{.r .cell-code}\nsd(estudiantes$ppa)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.6252488\n```\n:::\n\n```{.r .cell-code}\nrange(estudiantes$ppa)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 4.73 6.50\n```\n:::\n\n```{.r .cell-code}\nmax(estudiantes$ppa)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 6.5\n```\n:::\n\n```{.r .cell-code}\nmin(estudiantes$ppa)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 4.73\n```\n:::\n:::\n\nEn caso de que haya valores perdidos en alguna variable numérica y se desee realizar alguna operación matemática, se debe especificar `na.rm = TRUE`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmean(estudiantes$edad) # Como tiene NA, retornará NA.\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] NA\n```\n:::\n\n```{.r .cell-code}\nmean(estudiantes$edad, na.rm = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 50.125\n```\n:::\n\n```{.r .cell-code}\nsd(estudiantes$edad, na.rm = TRUE )\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 22.76863\n```\n:::\n:::\n\nPodemos redondear o truncar ese valor de la media, según sea necesario:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntrunc(mean(estudiantes$edad, na.rm = TRUE))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 50\n```\n:::\n\n```{.r .cell-code}\nround(mean(estudiantes$edad, na.rm = TRUE), digits = 2) # Dos decimales\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 50.12\n```\n:::\n:::\n\nY el valor entero que se encuentra más cercano a esa media es 51.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nceiling(mean(estudiantes$edad, na.rm = TRUE))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 51\n```\n:::\n:::\n\n    \nEn el caso de los cuantiles, en el siguiente ejemplo se pide el cuantil 0.10, que corresponde al percentil 10. Los resultados muestran que el 10% inferior tiene valores iguales o menores a 4.898 y el 90% superior de casos tiene un valor superior a 4.898.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nquantile(estudiantes$ppa, probs = 0.10)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  10% \n4.898 \n```\n:::\n:::\n\n\nSi se quisiera obtener esta información de manera resumida, la función `summary()` entregará parte de los resultados.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsummary(estudiantes$ppa)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n  4.730   5.060   5.240   5.511   6.120   6.500 \n```\n:::\n:::\n\n\nSi se desea tener más resultados, podemos hacerlo empleando los conocimientos que tenemos sobre vectores:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nc(summary = summary(estudiantes$ppa), sd = sd(estudiantes$ppa))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   summary.Min. summary.1st Qu.  summary.Median    summary.Mean summary.3rd Qu. \n      4.7300000       5.0600000       5.2400000       5.5111111       6.1200000 \n   summary.Max.              sd \n      6.5000000       0.6252488 \n```\n:::\n:::\n\nSi quisiéramos obtener todas las medidas de tendencia central, dispersión y posición que nos interesan en una sola línea, una manera sencilla de hacerlo es a través de un vector.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nc(media = mean(estudiantes$ppa), \n  mediana = median(estudiantes$ppa),\n  devest = sd(estudiantes$ppa),\n  min = min(estudiantes$ppa),\n  max = max(estudiantes$ppa),\n  rango = diff(range(estudiantes$ppa)), # En este caso diff es equivalente a restar.\n  p10 = unname(quantile(estudiantes$ppa, prob = 0.10)),\n  p25 = unname(quantile(estudiantes$ppa, prob = 0.25)),\n  p75 = unname(quantile(estudiantes$ppa, prob = 0.75)),\n  p90 = unname(quantile(estudiantes$ppa, prob = 0.90))\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n    media   mediana    devest       min       max     rango       p10       p25 \n5.5111111 5.2400000 0.6252488 4.7300000 6.5000000 1.7700000 4.8980000 5.0600000 \n      p75       p90 \n6.1200000 6.1960000 \n```\n:::\n:::\n\n::: {.callout-tip}\nLa función `unname()` se emplea para eliminar el nombre que R asigna al vector al momento de calcular el cuantil. Si se ejecuta el código `c(p10 = quantile(estudiantes$ppa, prob = 0.10))` notarán que el nombre queda como `p10.10%`.\n:::\n\n## Variables tipo caracter o string\n\nLas cadenas de texto o strings también cuentan con sus propias funciones. Algunas de ellas son:\n\n - `paste()`: concatena strings. Cuenta con el argumento `sep` para indicar el separador y el argumento `collapse`.\n  - `paste0()`: concatena strings. No tiene opción de especificar un separador. Es útil cuando se desea concatenar números que están como string. \n  - `strsplit()`: separa strings. Cuenta con el argumento `split` para indicar qué criterio se usará para dividir los textos. \n - `toupper()`: convierte a mayúsculas.\n - `tolower()`: convierte a minúsculas.\n - `nchar()`: retorna el número de caracteres.\n - `gsub()`: reemplaza texto siguiendo un patrón especificado.\n - `trimws()`: elimina los espacios en blanco al inicio y al final.\n \n Siguiendo con el conjunto de datos de estudiantes, dejaremos en una sola variable el nombre y el apellido, para luego eliminar esta última variable. \n \n\n::: {.cell}\n\n```{.r .cell-code}\nestudiantes[\"nombre_apellido\"] <- paste(estudiantes$nombre, estudiantes$apellido)\nestudiantes[, c(\"nombre\", \"apellido\")] <- NULL \n# Con NULL eliminamos completamente la columna nombre.\n```\n:::\n\nSi quisiéramos hacer la operación inversa, usamos la función `strsplit()`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# En este caso al correr el código dará warning, pero no se preocupen\nestudiantes[c(\"nombre\", \"apellido\")] <- do.call(\n  rbind, strsplit(estudiantes$nombre_apellido, split = \" \"))\n```\n:::\n\n::: {.callout-caution}\n`do.call()` es una función más avanzada de R que no veremos en profundidad en este curso, pues se utiliza para ejecutar funciones con la estructura de datos de `listas` (que se presentará más adelante como material complementario). Para mayor información pueden revisar este [enlace](https://www.statology.org/do-call-in-r/).\n:::\n\nAhora modificaremos el nombre y apellido a mayúscula.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nestudiantes[\"nombre\"] <- toupper(estudiantes$nombre)\nestudiantes[\"apellido\"] <- toupper(estudiantes$apellido)\n```\n:::\n\n::: {.callout-tip}\n\n¿Y si quisiéramos realizar la operación de arriba en una sola línea?\n\nLa función `lapply()` permtie aplicar otra función sobre una lista o un vector. Hay dos argumentos que nos resultarán relevantes:\n\n  - `X`: indica el vector o la lista a la que se les aplicará la función.\n  - `FUN`: indica la función que se aplicará a cada elemento de `X`.\n  \n¡En este caso ambos argumentos están en mayúsculas!\n\nEstas funciones también son más avanzadas y existen otros modos de aplicar estas operaciones de manera más eficiente. De todas formas, si alguien está interesado/a, puede revisar [aquí](https://ademos.people.uic.edu/Chapter4.html#:~:text=Apply%20functions%20are%20a%20family,and%20often%20require%20less%20code.).\n:::\n\n\n::: {.cell}\n\n```{.r .cell-code}\nestudiantes[c(\"nombre\", \"apellido\")] <- lapply(\n  X = estudiantes[c(\"nombre\", \"apellido\")], FUN = toupper)\nestudiantes\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  edad  ppa                       region       serie_fav     musica_fav\n6   80 5.24             Región del Ñuble          Los 80            Pop\n3   79 5.06 Región de Arica y Parinacota    Breaking Bad           Trap\n5   63 4.73         Región Metropolitana            Dark       Ranchera\n8   52 6.50        Región de Antofagasta            <NA>           Trap\n2   45 6.12       Región de La Araucanía     Los Soprano      Reggeaton\n7   35 4.94             Región del Maule        The Boys           Jazz\n1   29 5.75         Región Metropolitana Game of Thrones          Metal\n4   18 6.12         Región de Valparaíso    Breaking Bad Música Clásica\n9   NA 5.14         Región Metropolitana            <NA>        Hip hop\n  edad_mas_1            carrera  nombre_apellido    nombre  apellido\n6         81   Ciencia de Datos Magdalena Madrid MAGDALENA    MADRID\n3         80 Construcción Civil     Ernesto Leal   ERNESTO      LEAL\n5         64        Estadística   David Espinoza     DAVID  ESPINOZA\n8         53             Letras     Pilar Farías     PILAR    FARÍAS\n2         46         Ingeniería     Andrea Pérez    ANDREA     PÉREZ\n7         36        Odontología Santiago Vergara  SANTIAGO   VERGARA\n1         30     Trabajo Social Ismael Fernández    ISMAEL FERNÁNDEZ\n4         19         Sociología    Daniela Núñez   DANIELA     NÚÑEZ\n9         NA               <NA>   Julio Martínez     JULIO  MARTÍNEZ\n```\n:::\n:::\n\nTambién podemos imprimir el número de caracteres que tiene cada nombre:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnchar(estudiantes$nombre)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 9 7 5 5 6 8 6 7 5\n```\n:::\n:::\n\nY podríamos combinar algunas funciones de strings para que se vea de mejor forma en consola:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nprint(paste(estudiantes$nombre, nchar(estudiantes$nombre), sep = \":\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"MAGDALENA:9\" \"ERNESTO:7\"   \"DAVID:5\"     \"PILAR:5\"     \"ANDREA:6\"   \n[6] \"SANTIAGO:8\"  \"ISMAEL:6\"    \"DANIELA:7\"   \"JULIO:5\"    \n```\n:::\n:::\n\n::: {.callout-tip}\n\n`print()` retorna el objeto en la consola. \n\n- En general, no es necesario usar `print()`. Por ejemplo, en este documento hemos mostrado en consola el objeto `estudiantes` sin necesidad de usar esa función.\n- No obstante, print tiene algunas opciones de configuración que lo hacen útil en algunas ocasiones y además otorga mayor visibilidad sobre lo que se está realizando. \n:::\n\nAhora simplificaremos el texto presente en la variable `region`. Primero hay que observar el patrón:\n\n  - Todas comienzan con \"Región\".\n  - Algunas incluyen \"Región de\" y otras \"Región del\".\n\nDeseamos cambiar esto para que solamente quede el nombre de la región. Por lo tanto, reemplazaremos los textos indicados arriba por un espacio vacío.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nestudiantes[\"region_clean\"] <- gsub(\n  \"Región|Región de|Región del\", \"\", estudiantes$region)\nestudiantes$region_clean\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \" Ñuble\"              \" Arica y Parinacota\" \" Metropolitana\"     \n[4] \" Antofagasta\"        \" La Araucanía\"       \" Maule\"             \n[7] \" Metropolitana\"      \" Valparaíso\"         \" Metropolitana\"     \n```\n:::\n:::\n\nPero vemos que ahora tenemos espacios en blanco. Podemos quitarlos usando la función `trimws()`, que los eliminará al principio y al final de una cadena de caracteres.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nestudiantes[\"region_clean\"] <- trimws(estudiantes$region_clean)\nestudiantes$region_clean\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Ñuble\"              \"Arica y Parinacota\" \"Metropolitana\"     \n[4] \"Antofagasta\"        \"La Araucanía\"       \"Maule\"             \n[7] \"Metropolitana\"      \"Valparaíso\"         \"Metropolitana\"     \n```\n:::\n:::\n\n\n## Factores\n\nLos `factores` son un tipo especial de dato en R para los datos categóricos. Estos se utilizan cuando tenemos un número reducido de categorías predefinidas, los cuales son denominados `niveles` o `levels`. Se definen utilizando el constructor `factor()`.\n\nAlgunas de sus ventajas son:\n\n - Permiten controlar el número de categorías válidas.\n - Mayor flexibilidad para ordenar los elementos del factor, lo que facilita su implementación en gráficos, entre otros.\n\nPara este ejemplo agregaremos una nueva variable al conjunto de datos denominada `satisfaccion`. Esta consta de cinco categorías las cuales se corresponden:\n\n  1. Muy Insatisfecho/a.\n  2. Insatisfecho/a.\n  3. Ni insatisfecho/a ni satisfecho/a.\n  4. Satisfecho/a.\n  5. Muy satisfecho/a.\n  \n\n\n::: {.cell}\n\n```{.r .cell-code}\nestudiantes$satisfaccion <-  c(1, 3, 4, 5, 2, 6, 4, 5, 5) \n# Ingresamos 9 valores porque la data de estudiantes son 9\n\n# Son 8 valores porque se definió un valor 6 que no existe en el factor.\n\nestudiantes[\"satisfaccion\"] <- factor(estudiantes$satisfaccion,\n            levels = c(1, 2, 3, 4, 5),\n            labels = c(\"Muy insatisfecho/a\", \"Insatisfecho/a\", \n                       \"Ni insatisfecho/a ni satisfecho/a\",\n                       \"Satisfecho/a\", \"Muy satisfecho/a\"))\n```\n:::\n\n\n## Tablas\n\n::: {.callout-note}\nEsta sección pretende mostrar de manera suscinta y rápida la generación de tablas con R base. No vale la pena dedicarle mucho tiempo, pues existen paquetes que ofrecen opciones mucho más atractivas para formatear, visualizar y exportar tablas a distintos formatos.\n:::\n\nA partir de la variable de satisfacción creada, generaremos nuestra primera tabla de frecuencias. Las funciones relevantes para esto son las siguientes:\n\n - `table()`: permite crear tablas de frecuencia o contingencia mostrando sus frecuencias.\n - `prop.table()`: calcula las proporciones de una tabla de frecuencia o contingencia.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntable(estudiantes$satisfaccion)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\n               Muy insatisfecho/a                    Insatisfecho/a \n                                1                                 1 \nNi insatisfecho/a ni satisfecho/a                      Satisfecho/a \n                                1                                 2 \n                 Muy satisfecho/a \n                                3 \n```\n:::\n\n```{.r .cell-code}\ntable(estudiantes$satisfaccion, useNA = \"ifany\") \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\n               Muy insatisfecho/a                    Insatisfecho/a \n                                1                                 1 \nNi insatisfecho/a ni satisfecho/a                      Satisfecho/a \n                                1                                 2 \n                 Muy satisfecho/a                              <NA> \n                                3                                 1 \n```\n:::\n\n```{.r .cell-code}\n# Si se especifica ifany, mostrará los NA.\n```\n:::\n\nSi queremos obtener una tabla que incluya las proporciones.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nprop.table(table(estudiantes$satisfaccion)) \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\n               Muy insatisfecho/a                    Insatisfecho/a \n                            0.125                             0.125 \nNi insatisfecho/a ni satisfecho/a                      Satisfecho/a \n                            0.125                             0.250 \n                 Muy satisfecho/a \n                            0.375 \n```\n:::\n:::\n\nY si queremos la tabla como porcentajes:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nround(prop.table(table(estudiantes$satisfaccion)) * 100, digits = 1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\n               Muy insatisfecho/a                    Insatisfecho/a \n                             12.5                              12.5 \nNi insatisfecho/a ni satisfecho/a                      Satisfecho/a \n                             12.5                              25.0 \n                 Muy satisfecho/a \n                             37.5 \n```\n:::\n:::\n\nSi se desea que tenga los marginales podemos usar la función `addmargins()`. Además, con la función `cat()`, podemos modificar la forma en que se imprime en consola la tabla. En este caso, se indica que cada resultado debe ir separado por un salto de línea, el cual se especifica con `\\n`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntabla <- addmargins(round(prop.table(table(estudiantes$satisfaccion)) * 100, digits = 1))\ncat(paste(names(tabla), tabla, sep = \": \"), sep = \"\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nMuy insatisfecho/a: 12.5\nInsatisfecho/a: 12.5\nNi insatisfecho/a ni satisfecho/a: 12.5\nSatisfecho/a: 25\nMuy satisfecho/a: 37.5\nSum: 100\n```\n:::\n:::\n\n\n## Bonus: paquetes cargados e información de sesión\n\nA continuación se presentan algunas funciones que pueden resultar útiles para obtener información sobre nuestra sesión de R o modificar el comportamiento por defecto del software:\n\n - `options()`: función cuyos argumentos permiten cambiar el comportamiento por defecto de R en una serie de opciones. Algunas de estas son:\n    - `Out.Dec()`: especifica el caracter para indicar decimales. Por defecto es el punto, pero se puede cambiar a la coma.\n    - `scipen()`: deshabilita la notación científica. Se especifica mediante un valor, usualmente el 999, aunque podría ser otro según lo que se requiera.\n    - `max.print()`: modifica el número de líneas que pueden imprimirse en la consola. Por defecto es 99999. Por temas de rendimiento no se recomienda cambiarlo. \n- `search()`: indica las librerías de R que están cargadas en la sesión.\n- `sessionInfo()`: Entrega información sobre el sistema operativo, la versión de R utilizada, los paquetes cargados y su versión, entre otros. \n\n\n::: {.cell}\n\n```{.r .cell-code}\noptions(OutDec = \",\", # Decimales se muestran con coma\n        scipen = 999) # Desahabilita notación científica\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nsearch()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \".GlobalEnv\"        \"package:stats\"     \"package:graphics\" \n[4] \"package:grDevices\" \"package:utils\"     \"package:datasets\" \n[7] \"package:methods\"   \"Autoloads\"         \"package:base\"     \n```\n:::\n\n```{.r .cell-code}\nsessionInfo()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nR version 4.3.1 (2023-06-16 ucrt)\nPlatform: x86_64-w64-mingw32/x64 (64-bit)\nRunning under: Windows 11 x64 (build 22621)\n\nMatrix products: default\n\n\nlocale:\n[1] LC_COLLATE=Spanish_Chile.utf8  LC_CTYPE=Spanish_Chile.utf8   \n[3] LC_MONETARY=Spanish_Chile.utf8 LC_NUMERIC=C                  \n[5] LC_TIME=Spanish_Chile.utf8    \n\ntime zone: America/Santiago\ntzcode source: internal\n\nattached base packages:\n[1] stats     graphics  grDevices utils     datasets  methods   base     \n\nloaded via a namespace (and not attached):\n [1] digest_0.6.33     utf8_1.2.3        fastmap_1.1.1     xfun_0.40        \n [5] magrittr_2.0.3    glue_1.6.2        tibble_3.2.1      knitr_1.43       \n [9] pkgconfig_2.0.3   htmltools_0.5.6   rmarkdown_2.23    lifecycle_1.0.3  \n[13] cli_3.6.1         fansi_1.0.4       vctrs_0.6.3       compiler_4.3.1   \n[17] rstudioapi_0.15.0 tools_4.3.1       pillar_1.9.0      evaluate_0.21    \n[21] yaml_2.3.7        rlang_1.1.1       jsonlite_1.8.7    htmlwidgets_1.6.2\n```\n:::\n:::\n",
    "supporting": [
      "clase_2_notas_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}