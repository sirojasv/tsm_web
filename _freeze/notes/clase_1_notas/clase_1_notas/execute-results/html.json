{
  "hash": "f934e8df7755932404a7199c399d8b90",
  "result": {
    "markdown": "---\n# Título y Autor\ntitle: \"Notas clase 1: Introducción a R\"\nsubtitle: |\n    | Curso: Metodología Cuantitativa.\n    | Magíster en Trabajo Social, Pontificia Universidad Católica de Chile.\nauthor: \"Sebastián Rojas Vergara\"\n# date: \n# abstract: \n# thanks:\n# order: \n# Opciones de formato\nformat: \n  html:\n    # Fuente\n    # Despliegue de código\n    code-fold: false\n    code-line-numbers: true\n    # Tema\n    theme:\n      light: flatly\n      dark: darkly\n    highlight-style: haddock\n    # Autocontenido\n    self-contained: true\n    # estilos\n    css: styles.css\n# Tabla de contenidos\ntoc: true\ntoc-depth: 4\ntoc-location: right\n# Numeración\nnumber-sections: true\n# Figuras\nfig-align: center\nfig-cap-location: top\n# Notas al pie\nfootnotes-hover: true\n# Lenguaje\nlang: \"es\"\n# Ejecución de código\ncomments: false\nexecute: \n  echo: true\n---\n\n\n<img src=\"images/logo_puc_bn.png\" alt=\"Mi Imagen\" style=\"position: fixed; top: 0; right: 0; width: 150px; height: 90px;\">\n\n\n## Bases{.unnumbered}\n\nEn el siguiente documento se presentan aspectos importanes sobre vectores y matrices, así como una introducción a los dataframes y tibbles.\n\nComenzaremos cargando el paquete `tidyverse`, el cual será necesario para llamar a la función `tibble` que se usará más adelante.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\n```\n:::\n\n\n## Vectores\n\nLos **vectores** son arreglos unidimensionales que solo pueden contener **un tipo de dato**. \n\n### Crear vectores\n\nLos vectores se definen escribiendo `c()`, que viene del inglés *combine*. Cada uno de los elementos del vector se indican separando por coma. Se puede crear un objeto para guardar ese vector asignándole un nombre seguido de `<-`, como se muestra a continuación:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnombre_objeto <- c() # Adentro van los elementos del vector\n```\n:::\n\n\nPor ejemplo, en los siguientes casos se definen tres vectores que corresponden a tres tipos de datos revisados en clases: `numeric`, `character` y `logical`. Estos cumplen con el requisito de tener solamente datos de un mismo tipo.\n\nVector con elementos de tipo numérico\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Definiendo mi primer vector numérico\nv_numerico <- c(1, 3, 5, 7, 9)\n```\n:::\n\n\nAdemás, en el caso de los vectores numéricos se puede indicar una secuencia utilizando la notación de dos puntos `:`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Entrega un vector con valores del 1 al 5\nv_numerico_1 <- c(1:5)\nv_numerico_1 \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 2 3 4 5\n```\n:::\n:::\n\n\nO de igual forma se pueden combinar secuencias con números específicos y otra secuencia. Las secuencias pueden ser incrementales o decrementales.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Entrega un vector con valores del 1 al 5, 9 al 7 y el número 256\nv_numerico_2 <- c(1:5, 9:7, 256)\nv_numerico_2 \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]   1   2   3   4   5   9   8   7 256\n```\n:::\n:::\n\n\nVector con elementos de tipo caracter.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Definiendo mi primer vector de caracteres\nv_caracteres <- c(\"Hola Magíster de Trabajo Social\", \"Año 2023\")\n```\n:::\n\n\nVector con elementos de tipo lógico.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Definiendo mi primer vector logico\nv_logico <- c(TRUE, FALSE, TRUE, FALSE, TRUE)\n```\n:::\n\n\nSe puede comprobar que el elemento definido es un vector utilizando la función `is.vector()`. Esta recibe como argumento (lo que va dentro del paréntesis) el nombre del objeto. Si es un vector, retornará `TRUE`, y si no lo es, devolverá `FALSE`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Comprobando que es un vector\nis.vector(v_numerico)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n:::\n\n\nPara cualquier vector es posible obtener su largo, es decir, el número de elementos que contiene, usando la función `length()`. Esta función retornará el valor que corresponde al largo de ese vector.\n\nEn el caso del vector numérico de ejemplo, este consta de 5 elementos.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Obteniendo el largo del vector\nlength(v_numerico)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 5\n```\n:::\n:::\n\n\nPodemos comprobar el tipo de dato del vector utilizando las funciones `class()` y `typeof()`\n\n  - La función `class()` devuelve la clase del objeto.\n  - La función `typeof()` determina el método interno que usa R para guardar ese objeto.\n  \n\n::: {.cell}\n\n```{.r .cell-code}\n# Comprobamos la clase del vector numérico\nclass(v_numerico)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"numeric\"\n```\n:::\n\n```{.r .cell-code}\ntypeof(v_numerico)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"double\"\n```\n:::\n\n```{.r .cell-code}\n# Comprobamos la clase del vector de caracteres\nclass(v_caracteres)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"character\"\n```\n:::\n\n```{.r .cell-code}\ntypeof(v_caracteres)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"character\"\n```\n:::\n\n```{.r .cell-code}\n# Comprobamos la clase del vector lógico\nclass(v_logico)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"logical\"\n```\n:::\n\n```{.r .cell-code}\ntypeof(v_logico)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"logical\"\n```\n:::\n:::\n\n\nLos vectores pueden elementos vacíos que se denotan como `NA`, que es un acrónimo de *Not Available*. Esto se utiliza para indicar la ausencia de un valor. Si el valor `NA` está definido en el vector, este contará como un elemento más.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Definiendo un vector numérico con NA\nv_numerico_na <- c(5, 10, 33, 77, 101, 256, 5, NA, NA)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Definiendo un vector de caracteres con NA\nv_caracteres_na <- c(\"Hola\", \"Primera Clase\", NA)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Definiendo un vector lógico con NA\nv_logico_na <- c(TRUE, FALSE, NA)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nlength(v_numerico_na)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 9\n```\n:::\n\n```{.r .cell-code}\nlength(v_caracteres_na)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 3\n```\n:::\n\n```{.r .cell-code}\nlength(v_logico_na)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 3\n```\n:::\n:::\n\n\n\n### Acceso a elementos\n\nCada elemento de un vector tiene una posición asignada, comenzando desde el 1. Para acceder a la posición del vector indicaremos el nombre del vector, seguido de paréntesis cuadrados [] (i.e. `nombre_objeto[]`).\n\nPor ejemplo, podemos acceder al segundo elemento del vector numérico y del vector de caracteres.\n\n  \n\n::: {.cell}\n\n```{.r .cell-code}\n# Acceder a la segunda posición\nv_numerico[2]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 3\n```\n:::\n\n```{.r .cell-code}\nv_caracteres[2]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Año 2023\"\n```\n:::\n:::\n\n\nUtilizando el símbolo de dos puntos `:` se puede indicar un rango de posiciones del vector a las que se quiere acceder.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Acceder a las tres primeras posiciones del vector\nv_numerico[1:3]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 3 5\n```\n:::\n:::\n\n\nDe igual forma, se pueden utilizar otras funciones de `R` para acceder a posiciones del vector. Por ejemplo, la función `length()` devuelve el largo de un vector (también funciona para otras estructuras de datos)\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Accede siempre a la última posición sin conocer a priori su largo\nv_numerico[length(v_numerico)]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 9\n```\n:::\n:::\n\n\nY si se quiere acceder a la penúltima posición, basta con obtener el largo del vector y restarle 1.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Accede siempre a la penúltima posición sin conocer a priori su largo.\nv_numerico[length(v_numerico) - 1]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 7\n```\n:::\n:::\n\n\nEn caso de acceder a una posición que no esté definida, el programa indicará un valor vacío denonado por `NA`\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Notar que en el vector definido no existe la posición 3\nv_caracteres[3]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] NA\n```\n:::\n:::\n\n\n### Modificar o eliminar elementos\n\nDado un vector ya creado, es posible modificar o eliminar elementos de este. Si se desea eliminar, se debe anteponer un signo menos `-` indicando la posición que se quiere eliminar.\n\nEn el ejemplo a continuación definimos usando un vector usando la función `seq`, que corresponde a una secuencia que toma tres argumentos:\n\n  - from: indica el comienzo de la secuencia\n  - to: indica el final de la secuencia\n  - by: indica el incremento de la secuencia\n  \n\n\n::: {.cell}\n\n```{.r .cell-code}\nv_completo <- seq(from = 10, to = 50, by = 10)\nv_completo \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 10 20 30 40 50\n```\n:::\n\n```{.r .cell-code}\n# Ahora eliminaremos el elemento que corresponda a la quinta posición\nv_cortado <- v_completo[-4]\nv_cortado\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 10 20 30 50\n```\n:::\n:::\n\nY ahora modificaremos el valor 50 para que pase a ser 90.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Ahora al valor que corresponde a 50 le asignaremos el valor 90.\nv_cortado[v_cortado == 50] <- 90\nv_cortado\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 10 20 30 90\n```\n:::\n:::\n\n\n:::{.callout-note}\nExisten muchas más operaciones para vectores, como ordenarlos, reemplazar texto, generar reglas de reemplazo, etc. Estas se irán revisando a lo largo del curso con las funciones del paquete `tidyverse()`\n:::\n\n### Combinar vectores\n\nSe pueden agregar elementos a un vector ya existente. Para ello, se puede emplear emplear la misma notación `c()`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Combinando vectores\n\nmi_vector <- c(\"Los juegos\")\nmi_vector <- c(mi_vector, \"del hambre\")\n# Notar que ahora este vector tiene dos elementos\nmi_vector\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Los juegos\" \"del hambre\"\n```\n:::\n:::\n\n\nTambién se pueden crear vectores que son combinaciones de vectores\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Creando vectores a partir de combinaciones de vectores\nmi_vector_1 <- c(1, 3, 5, 7)\nmi_vector_2 <- c(2, 4, 6, 8)\nmi_vector_3 <- c(mi_vector_1, mi_vector_2)\nmi_vector_3\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 3 5 7 2 4 6 8\n```\n:::\n:::\n\n\n### Coerción\n\nCuando se crean o combinan vectores que tipos de datos diferentes, `R` realizará un proceso de **coerción** automáticamente. Es decir, buscará convertir los datos al tipo más flexible, siguiente unas reglas de jerarquía. El caso más simple es cuando se tienen datos de tipo `numeric` y `character`, donde el programa forzará a que los datos sean de este último tipo.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Al definirse tiene datos de distinto tipo\nmi_vector_coercion <- c(40, \"50 años\", 33, \"33\") # Las comillas indican que es texto\n\n# Pero R genera una coerción\nclass(mi_vector_coercion)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"character\"\n```\n:::\n:::\n\n\n### Operaciones con vectores\n\nTambién se pueden realizar operaciones matemáticas con los vectores, tales como sumas, multiplicaciones, restas, etc.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Multiplicar el vector por 2\nmi_vector_multiplicar <- c(2, 4, 6) * 2\nmi_vector_multiplicar\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  4  8 12\n```\n:::\n:::\n\n\nComo se puede apreciar, la operación de multiplicar se está aplicando a cada uno de los elementos del vector. \n\nEsto nos introduce a un concepto de `R` conocido como **vectorización**. Esto quiere decir que hay operaciones que se aplican a cada uno de los elementos. \n\nLa vectorización funciona con otras estructuras de datos que veremos a lo largo del curso. Intuitivamente, bastará conocer que cuando una operación se puede vectorizar, su tiempo de ejecución es muy rápido.\n\n### Reciclar vectores\n\nCuando dos vectores no tienen el mismo largo, `R` realizará un proceso que se conoce como reciclaje. Este consiste en que irá tomando cada uno de los valores del vector más corto para que operen con los elementos del vector que aún no tienen su \"pareja\". \n\nEn el ejemplo que se presenta a continuación, se han sumado los valores del siguiente modo:\n\n$$\n\\begin{gathered}\n\\ 2 + 4 \n\\\\\n\\ 2 + 5\n\\\\\n\\text{Se acaban los valores del primer vector} \n\\\\\n\\ 2 + 6 \n\\\\\n\\ 3 + 8\n\\\\\n\\text{Se recicla el valor 2 y 3 del primer vector} \n\\end{gathered}\n$$\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Vectores de distinto tipo\nv_largo2 <- c(2, 3)\nv_largo3 <- c(4, 5, 6, 8)\nv_largo_com <- v_largo2 + v_largo3\nv_largo_com\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  6  8  8 11\n```\n:::\n:::\n\n\n## Matrices\n\nLas matrices son arreglos bidisimensionales que solo pueden contener un tipo de dato. Las matrices son una estructura con forma rectangular, formada por filas y columnas.\n\n### Crear matrices\n\nSe definen escribiendo `matrix()`. Al menos cuatro argumentos nos resultarán relevantes de las matrices:\n\n  - data: indica el vector de datos de la matriz\n  - nrow: indica el número de filas\n  - ncol: indica el número de columnas\n  - byrow: indica si el llenado es por filas o columnas. Por defecto viene en llenado por columnas.\n  \nEjemplo de llenado por columnas\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmatriz_1 <- matrix(1:9, ncol = 3) # Llenado por columnas\nmatriz_1\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3]\n[1,]    1    4    7\n[2,]    2    5    8\n[3,]    3    6    9\n```\n:::\n:::\n\nEjemplo de llenado por filas\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmatriz_2 <- matrix(1:9, ncol = 3, byrow = TRUE) # Llenado por filas\nmatriz_2\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3]\n[1,]    1    2    3\n[2,]    4    5    6\n[3,]    7    8    9\n```\n:::\n:::\n\n\n### Crear matriz a partir de vectores\n\nEs posible crear matrices a partir de la unión de vectores. Para ello se pueden usar las siguientes funciones:\n\n  - `cbind` que viene de *column bind* (unión por columnas) donde cada vector corresponde a una columna.\n  - `rbind` que viene de *row bind* (unión por filas)\n\nEjemplos:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nv_parte_1 <- c(1:2)\nv_parte_2 <- c(3:4)\nv_parte_3 <- c(5:6)\nv_parte_4 <- c(7:8)\n\nmatriz_columna <- cbind(v_parte_1, v_parte_2, v_parte_3, v_parte_4)\nmatriz_columna\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     v_parte_1 v_parte_2 v_parte_3 v_parte_4\n[1,]         1         3         5         7\n[2,]         2         4         6         8\n```\n:::\n\n```{.r .cell-code}\nmatriz_fila <- rbind(v_parte_1, v_parte_2, v_parte_3, v_parte_4)\nmatriz_fila \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n          [,1] [,2]\nv_parte_1    1    2\nv_parte_2    3    4\nv_parte_3    5    6\nv_parte_4    7    8\n```\n:::\n:::\n\n\n### Acceso a elementos\n\nEn R las matrices siempre siguen el orden (filas, columnas). Con esta lógica se puede seleccionar sus elementos: \n\n$$\n\\begin{gathered}\n\\ \\text{matriz}[i,j]\n\\end{gathered}\n$$\n$$\n\\begin{aligned}\n\\text{Donde:} \n\\\\\n\\ \\text{matriz}[i,] = \\text{selecciona la \\textbf{fila} i-ésima de la matriz.} \n\\\\\n\\ \\text{matriz}[, j] = \\text{selecciona la \\textbf{columna} j-ésima de la matriz.} \n\\\\\n\\ \\text{matriz}[i, j] = \\text{selecciona el j-ésimo elemento de la i-ésima fila} \n\\end{aligned}\n$$\n   \nRealicemos un ejemplo con la `matriz_2`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmatriz_2[1, 1] # Estoy seleccionando la fila 1 columna 1\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1\n```\n:::\n\n```{.r .cell-code}\nmatriz_2[2, 1] # Estoy seleccionando la fila 2 columna 1\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 4\n```\n:::\n\n```{.r .cell-code}\nmatriz_2[1, ] # Estoy seleccionando a toda la fila 1\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 2 3\n```\n:::\n\n```{.r .cell-code}\nmatriz_2[3, ] # Estoy seleccionando a toda la fila 3\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 7 8 9\n```\n:::\n\n```{.r .cell-code}\nmatriz_2[, 1] # Estoy seleccionando a toda la columna 1\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 4 7\n```\n:::\n:::\n\n\n## Dataframes y tibbles \n\n### Generando dataframes y tibbles\n\nEn R los **dataframes** son arreglos de datos bidimensionales (filas y columnas), pero que permiten distintos tipos de datos.\n\nEs el caso usual de datos estructurados que se ven en los cursos de análisis de datos: las filas representan observaciones y las columnas variables.\n\nLos **tibbles** son muy similares a los dataframe, pero con mejoras de calidad de vida. La función proviene del paquete `tidyverse`.\n\nLos dataframes se generan a través de la función `data.frame()`, mientras que los tibbles con `tibble()`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Se definen los vectores de datos\nnombre <- c(\"Constanza\", \"Sofia\", \"Gonzalo\")\ncarrera <- c(\"Ingeniería\", \"Administración\", \"Arqueología\")\ngen <- c(2013, 2018, 2023)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Generando una base de datos con data.frame()\ndata_estudiantes_df <- data.frame(nombre, carrera, gen)\ndata_estudiantes_df\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     nombre        carrera  gen\n1 Constanza     Ingeniería 2013\n2     Sofia Administración 2018\n3   Gonzalo    Arqueología 2023\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Generando una base de datos con tibble()\ndata_estudiantes_tb <- tibble(nombre, carrera, gen)\ndata_estudiantes_tb\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 3 × 3\n  nombre    carrera          gen\n  <chr>     <chr>          <dbl>\n1 Constanza Ingeniería      2013\n2 Sofia     Administración  2018\n3 Gonzalo   Arqueología     2023\n```\n:::\n:::\n\n\n### Acceder a elementos\n\nEn los tibbles y dataframes uno también puede seleccionar directamente filas o columnas. Para ello, existen dos opciones:\n\n  - Usar la notación de `$` para acceder a columnas específicas.\n\n  - Usar la notación de `[[]]` para acceder a columnas específicas.\n\n  - Usar la notación de matrices `[i, j]` para acceder a filas y columnas.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnombre_base$nombre_variable\nnombre_base[i, j]\nnombre_base[[]]\n```\n:::\n\n\nEjemplos:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata_estudiantes_tb$nombre # accedemos a la columna nombre con $. Esto devuelve un vector\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Constanza\" \"Sofia\"     \"Gonzalo\"  \n```\n:::\n\n```{.r .cell-code}\ndata_estudiantes_tb[\"nombre\"] # accedemos a la columna nombre con []. Esto devuelve un tibble\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 3 × 1\n  nombre   \n  <chr>    \n1 Constanza\n2 Sofia    \n3 Gonzalo  \n```\n:::\n\n```{.r .cell-code}\ndata_estudiantes_tb[[\"nombre\"]] # accedemos a la columna nombre con[[]] Esto devuelve un vector\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Constanza\" \"Sofia\"     \"Gonzalo\"  \n```\n:::\n\n```{.r .cell-code}\ndata_estudiantes_tb[[1]] # accedemos a la columna nombre con notación por posición [[]]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Constanza\" \"Sofia\"     \"Gonzalo\"  \n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ndata_estudiantes_tb[1, \"nombre\"] # accedemos a la fila 1 de la columna nombre\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1 × 1\n  nombre   \n  <chr>    \n1 Constanza\n```\n:::\n\n```{.r .cell-code}\ndata_estudiantes_tb[1:2, \"nombre\"] # accedemos a la fila 1 y 2 de la columna nombre\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 2 × 1\n  nombre   \n  <chr>    \n1 Constanza\n2 Sofia    \n```\n:::\n\n```{.r .cell-code}\ndata_estudiantes_tb[[3, 1]] # Accedemos a la fila 3 para la columna 1\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Gonzalo\"\n```\n:::\n\n```{.r .cell-code}\ndata_estudiantes_tb[3, 1] # Accedemos a la fila 3 para la columna 1\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1 × 1\n  nombre \n  <chr>  \n1 Gonzalo\n```\n:::\n\n```{.r .cell-code}\n# Notar que las dos instrucciones de arriba son equivalentes, pero la primera devuelve un vector.\n\ndata_estudiantes_tb[1,] # Accedemos a toda la fila 1\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1 × 3\n  nombre    carrera      gen\n  <chr>     <chr>      <dbl>\n1 Constanza Ingeniería  2013\n```\n:::\n\n```{.r .cell-code}\ndata_estudiantes_tb[1,3] # Accedemos a la fila 1 columna 3\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1 × 1\n    gen\n  <dbl>\n1  2013\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ndata_estudiantes_tb[, -c(1)] # accedemos a todas las columnas menos nombre, por posición\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 3 × 2\n  carrera          gen\n  <chr>          <dbl>\n1 Ingeniería      2013\n2 Administración  2018\n3 Arqueología     2023\n```\n:::\n\n```{.r .cell-code}\ndata_estudiantes_tb[, -c(1:2)] # accedemos a todas las columnas menos la 1 y la 2\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 3 × 1\n    gen\n  <dbl>\n1  2013\n2  2018\n3  2023\n```\n:::\n\n```{.r .cell-code}\ndata_estudiantes_tb[, names(data_estudiantes_tb) != \"nombre\"] # accedemos a todas las columnas menos nombre\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 3 × 2\n  carrera          gen\n  <chr>          <dbl>\n1 Ingeniería      2013\n2 Administración  2018\n3 Arqueología     2023\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ndata_estudiantes_tb[, !names(data_estudiantes_tb) %in% c(\"nombre\", \"carrera\")]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 3 × 1\n    gen\n  <dbl>\n1  2013\n2  2018\n3  2023\n```\n:::\n:::",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}