{
  "hash": "26ba4776ef9737003732f63adf6fa9e7",
  "result": {
    "markdown": "---\n# Title & Author\ntitle: \"Tidyverse II\"\nsubtitle: | \n    | Metodología Cuantitativa - TSM301\n    | Clase 4\nauthor: \"Sebastián Rojas Vergara - sirojas1@uc.cl\"\n#institute:\n#order:\ndate: 09/13/2023\ndate-format: \"dddd D MMMM, YYYY\"\n# Format Options\nformat:\n  revealjs: \n    slide-number: true\n    transition: slide\n    transition-speed: slow\n    #chalkboard: \n      #buttons: false\n    smaller: true\n    controls: true\n    toc: false\n    number-sections: false\n    highlight-style: github\n    fig-dpi: 400\n    fig-cap-location: top\n    fig-responsive: true\n    embed-resources: true\n    preview-links: auto\n    theme: [dark, violet.scss]\n    logo: images/logo_puc_bn.png\n    # css: styles.css\n    footer: \"Metodología Cuantitativa - 2023\"\ncomments: false\nexecute: \n  echo: true\n---\n\n\n## Contenidos\n\n**I. Creación de variables**\n\n**II. Condicionales y recodificaciones**\n\n**III. Ejercicio**\n\n##  {background-color=\"rgb(25,25,25)\"}\n\n::: center-xy\n::: large-text\n<br> I. Creación de variables <br>\n:::\n:::\n\n## Creación de variables\n\nEn R existen funciones que permiten crear o modificar variables. Estas son particularmente útiles cuando:\n\n- Recodificar variables.\n- Crear nuevas variables a partir de otras.\n- Limpiar variables.\n- Cambiar el formato a las variables.\n\n\n## Función mutate (1)\n\nEl comando `mutate()` permite crear nuevas columnas en el mismo conjunto de datos.\n\nEn forma gráfica gracias a [Allison Horts](https://allisonhorst.com/r-packages-functions).  \n  \n![](images/mutate.png){width=\"350\" height=\"auto\" fig-align=\"center\"}\n\n## Función mutate (2)\n\nCargaremos unos datos de ejemplo con información de la franquicia Star Wars, que se encuentran alojados en `dplyr`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nprint(starwars)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 87 × 14\n   name     height  mass hair_color skin_color eye_color birth_year sex   gender\n   <chr>     <int> <dbl> <chr>      <chr>      <chr>          <dbl> <chr> <chr> \n 1 Luke Sk…    172    77 blond      fair       blue            19   male  mascu…\n 2 C-3PO       167    75 <NA>       gold       yellow         112   none  mascu…\n 3 R2-D2        96    32 <NA>       white, bl… red             33   none  mascu…\n 4 Darth V…    202   136 none       white      yellow          41.9 male  mascu…\n 5 Leia Or…    150    49 brown      light      brown           19   fema… femin…\n 6 Owen La…    178   120 brown, gr… light      blue            52   male  mascu…\n 7 Beru Wh…    165    75 brown      light      blue            47   fema… femin…\n 8 R5-D4        97    32 <NA>       white, red red             NA   none  mascu…\n 9 Biggs D…    183    84 black      light      brown           24   male  mascu…\n10 Obi-Wan…    182    77 auburn, w… fair       blue-gray       57   male  mascu…\n# ℹ 77 more rows\n# ℹ 5 more variables: homeworld <chr>, species <chr>, films <list>,\n#   vehicles <list>, starships <list>\n```\n:::\n:::\n\n\n## Función mutate (3)\n\nEl conjunto contiene el nombre del personaje, su altura en centímetros y el peso en kilogramos. Con esta información podríamos crear una nueva columna que corresponda a su IMC.\n\nEl Índice de Masa Corporal (IMC) corresponde al peso en kilogramos dividido por el cuadrado de la estatura en metros.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndatos <- starwars\ndatos |> select(name, height, mass)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 87 × 3\n   name               height  mass\n   <chr>               <int> <dbl>\n 1 Luke Skywalker        172    77\n 2 C-3PO                 167    75\n 3 R2-D2                  96    32\n 4 Darth Vader           202   136\n 5 Leia Organa           150    49\n 6 Owen Lars             178   120\n 7 Beru Whitesun lars    165    75\n 8 R5-D4                  97    32\n 9 Biggs Darklighter     183    84\n10 Obi-Wan Kenobi        182    77\n# ℹ 77 more rows\n```\n:::\n:::\n\n\n## Función mutate (4)\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndatos <- datos |> \n  mutate(altura_mt = height/100,\n         peso_kg = mass,\n         imc = peso_kg / (altura_mt^2))\ndatos |> select(name, height, mass, altura_mt, peso_kg, imc)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 87 × 6\n   name               height  mass altura_mt peso_kg   imc\n   <chr>               <int> <dbl>     <dbl>   <dbl> <dbl>\n 1 Luke Skywalker        172    77      1.72      77  26.0\n 2 C-3PO                 167    75      1.67      75  26.9\n 3 R2-D2                  96    32      0.96      32  34.7\n 4 Darth Vader           202   136      2.02     136  33.3\n 5 Leia Organa           150    49      1.5       49  21.8\n 6 Owen Lars             178   120      1.78     120  37.9\n 7 Beru Whitesun lars    165    75      1.65      75  27.5\n 8 R5-D4                  97    32      0.97      32  34.0\n 9 Biggs Darklighter     183    84      1.83      84  25.1\n10 Obi-Wan Kenobi        182    77      1.82      77  23.2\n# ℹ 77 more rows\n```\n:::\n:::\n\n\n## Función mutate (5)\n\nPuede emplearse en combinación con otras funciones y/ paquetes. Por ejemplo:\n\n- Funciones matemáticas.\n- Condicionales: `if_else`, `case_when`.\n- Asignar casos perdidos: `na_if()`.\n- Si la variable es caracter, resulta útil el paquete `stringr`.\n- Si es de tipo fecha, resulta útil `lubridate`.\n- Si es factor, resulta útil `forcats`.\n\n## Estadísticas agrupadas (1)\n\nEn múltiples ocasiones nos interesará realizar operaciones a partir de agrupaciones. Por ejemplo, si quisiéramos saber el IMC sexo. En estos casos se debe usar `group_by()`.\n\nUna vez realizada la operación, debe desagruparse el tibble con `ungroup()`.\n\nPor ejemplo, si quisiéramos la media de IMC por sexo:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndatos <- datos |> \n  group_by(sex) |> \n  mutate(imc_sex = mean(imc, na.rm = TRUE)) |> \n  ungroup()\ndatos |> select(name, sex, imc, imc_sex)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 87 × 4\n   name               sex      imc imc_sex\n   <chr>              <chr>  <dbl>   <dbl>\n 1 Luke Skywalker     male    26.0    25.7\n 2 C-3PO              none    26.9    32.7\n 3 R2-D2              none    34.7    32.7\n 4 Darth Vader        male    33.3    25.7\n 5 Leia Organa        female  21.8    19.2\n 6 Owen Lars          male    37.9    25.7\n 7 Beru Whitesun lars female  27.5    19.2\n 8 R5-D4              none    34.0    32.7\n 9 Biggs Darklighter  male    25.1    25.7\n10 Obi-Wan Kenobi     male    23.2    25.7\n# ℹ 77 more rows\n```\n:::\n:::\n\n\n## Estadísticas agrupadas (2)\n\nEn las últimas versiones de `dplyr` se agregó una nueva sintaxis que simplifica las agrupaciones. \n\nEl argumento `.by` permite realizar operaciones agrupadas y luego se desagrupa automáticamente.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndatos <- datos |> \n  mutate(imc_sex = mean(imc, na.rm = TRUE),\n         .by = sex) \ndatos |> select(name, sex, imc, imc_sex)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 87 × 4\n   name               sex      imc imc_sex\n   <chr>              <chr>  <dbl>   <dbl>\n 1 Luke Skywalker     male    26.0    25.7\n 2 C-3PO              none    26.9    32.7\n 3 R2-D2              none    34.7    32.7\n 4 Darth Vader        male    33.3    25.7\n 5 Leia Organa        female  21.8    19.2\n 6 Owen Lars          male    37.9    25.7\n 7 Beru Whitesun lars female  27.5    19.2\n 8 R5-D4              none    34.0    32.7\n 9 Biggs Darklighter  male    25.1    25.7\n10 Obi-Wan Kenobi     male    23.2    25.7\n# ℹ 77 more rows\n```\n:::\n:::\n\n\n## Estadísticas agrupadas (3)\n\nOtra opción para realizar estadísticas agrupadsa es la función `summarise()`. Esta también crea nueva columnas, pero retornará un **nuevo tibble** que contendrá tantas filas como categorías tenga la variable de agrupación.\n\nSe puede usar con `group_by()` o el argumento `.by`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndatos_agrupados_1 <- datos |> \n  group_by(sex) |> \n  summarise(imc_sex = mean(imc, na.rm = TRUE)) |> \n  ungroup()\ndatos_agrupados_1\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 5 × 2\n  sex            imc_sex\n  <chr>            <dbl>\n1 female            19.2\n2 hermaphroditic   443. \n3 male              25.7\n4 none              32.7\n5 <NA>              15.1\n```\n:::\n:::\n\n\n## Estadísticas agrupadas (4)\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndatos_agrupados_2 <- datos |> \n  summarise(imc_sex = mean(imc, na.rm = TRUE),\n            .by = sex)\ndatos_agrupados_2\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 5 × 2\n  sex            imc_sex\n  <chr>            <dbl>\n1 male              25.7\n2 none              32.7\n3 female            19.2\n4 hermaphroditic   443. \n5 <NA>              15.1\n```\n:::\n:::\n\n\n##  {background-color=\"rgb(25,25,25)\"}\n\n::: center-xy\n::: large-text\n<br> II. Condicionales y recodificaciones <br>\n:::\n:::\n\n## Función if_else() (1)\n\n¿Y si quisiéramos categorizar a las personas a partir de su IMC? En ese casoo se requiere emplear condiciones lógicas para transformar la variable.\n\nCrearemos una nueva variable categórica que asigne un estado según el rango del IMC. \n\nLa función `if_else()` facilita esta tarea. Consta de cuatro argumentos que nos interesan.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nif_else(condition, true, false, missing = NULL, ..., ptype = NULL, size = NULL)\n```\n:::\n\n\n- `condition`: se especifica la condición lógica que se evaluará.\n- `true`: indica el valor que debe asignarse cuando la condición es verdadera.\n- `false`: indica el valor que debe asignarse cuando la condición es falsa.\n- `missing`: indicaqué valor deben tomar los casos perdidos. Por defecto siempre será missing.\n\n## Función if_else() (2)\n\nCrearemos una variable que asigne \"25 o más\" a todos los casos que tengan un IMC igual o superior a 25.0 y \"Menos de 25\" a todos los casos con valores menores.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndatos <- datos |> \n  mutate(imc_dummy = \n           if_else(imc >= 25.0, \"25 o más\", \"Menos de 25\", NA_character_))\ndatos |> \n  select(name, imc, imc_dummy)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 87 × 3\n   name                 imc imc_dummy  \n   <chr>              <dbl> <chr>      \n 1 Luke Skywalker      26.0 25 o más   \n 2 C-3PO               26.9 25 o más   \n 3 R2-D2               34.7 25 o más   \n 4 Darth Vader         33.3 25 o más   \n 5 Leia Organa         21.8 Menos de 25\n 6 Owen Lars           37.9 25 o más   \n 7 Beru Whitesun lars  27.5 25 o más   \n 8 R5-D4               34.0 25 o más   \n 9 Biggs Darklighter   25.1 25 o más   \n10 Obi-Wan Kenobi      23.2 Menos de 25\n# ℹ 77 more rows\n```\n:::\n:::\n\n\n## Función case_when() (1)\n\nCuando queremos hacer más de una condición lógica `if_else()` se vuelve menos manejable. Para esos escenarios, está la función `case_when()`, que es una versión generalizada que permite asignar múltiples condiciones. Su estructura es la siguiente.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncase_when(..., .default = NULL, .ptype = NULL, .size = NULL)\n```\n:::\n\n\n- En la parte de la izquierda siempre se escribe la condición lógica que se desea comprobar.\n- Luego, lo que está a la derecha del símbolo de la virgulilla indica cuál será el resultado que se asignará cuando se cumpla la condición.\n- El argumento `.default` indica qué pasará cuando no se cumpla ninguna. Por defecto pasarán a ser missing.\n- Si queremos mantener los valores anteriores cuando no se cumpla ninguna condición, en el argumento .default se puede espeficiar el mismo valor que tenía la variable antes.\n\n## Función case_when() (2)\n\nVeamos un ejemplo hipotético de una base de datos con una variable edad en la cual crear una edad en tramos. 1) Niños/as (0 a 14 años); 2) Jóvenes (15 a 29); 3) Adultos (30 a 59); 4) Adultos mayores (60 y más).\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata_hipotetica = tibble(edad = c(60, 30, 14, 5, 70, NA, 66, 25, 8, 1, 95, 44, 150))\ndata_hipotetica <- data_hipotetica |> \n  mutate(edad_tramos = \n           case_when(edad %in% 0:14 ~ 1,\n                     edad %in% 15:29 ~ 2,\n                     edad %in% 30:59 ~ 3,\n                     edad >= 60 ~ 4,\n                     .default = NA_integer_\n                     )\n         )\ndata_hipotetica |> slice_head(n = 10)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 10 × 2\n    edad edad_tramos\n   <dbl>       <dbl>\n 1    60           4\n 2    30           3\n 3    14           1\n 4     5           1\n 5    70           4\n 6    NA          NA\n 7    66           4\n 8    25           2\n 9     8           1\n10     1           1\n```\n:::\n:::\n\n\n## Función case_when() (3)\n\nAhora supongamos otro ejemplo donde queremos crear una columna con la edad, pero que excluya los casos con valores superiores a 120 años.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata_hipotetica = tibble(edad = c(60, 30, 14, 5, 70, NA, 66, 25, 8, 1, 95, 44, 150))\ndata_hipotetica <- data_hipotetica |> \n  mutate(edad_limpia = \n           case_when(edad >= 120 ~ NA_integer_,\n                     .default = edad\n                     )\n         )\ndata_hipotetica\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 13 × 2\n    edad edad_limpia\n   <dbl>       <dbl>\n 1    60          60\n 2    30          30\n 3    14          14\n 4     5           5\n 5    70          70\n 6    NA          NA\n 7    66          66\n 8    25          25\n 9     8           8\n10     1           1\n11    95          95\n12    44          44\n13   150          NA\n```\n:::\n:::\n\n\n## Consideraciones (1)\n\nTanto para función `case_when()` como `if_else()` se debe tener en cuenta el tipo de dato al momento de especificar los valores perdidos. En concreto, debemos pedir el tipo que corresponda a la nueva variable que crearemos.\n\n- `NA`: para especificar casos perdidos en variables lógicas o booleanas que tienen valores `TRUE` o `FALSE`.\n- `NA_real_`: para especificar los casos perdidos en variables con números reales.\n- `NA_integer_`: para especificar los casos perdidos en variables con números enteros.\n- `NA_character_`: para especificar los casos perdidos en variables de tipo carácter.\n\n## Consideraciones (2)\n\nSe puede cambiar el tipo de una variable empleando las siguientes funciones según corresponda al tipo de dato.\n\nSe debe tener en cuenta que si R no puede convertir el tipo de dato adecuadamente para una celda específica, lo transformará en `NA`.\n\n- `as.character`: transforma la variable al tipo `character`.\n- `as.numeric`: transforma la variable al tipo `numeric`.\n- `as.logic`: transforma la variable al tipo `logic`.\n- `as_factor`: esta función especial con guión bajo permite transformar a `factor`. Proviene del paquete haven.\n\nY muchas más.\n\n## {background-color=\"rgb(25,25,25)\"}\n\n::: center-xy\n::: large-text\n<br> III. Ejercicio <br>\n:::\n:::\n\n## Ejercicio\n\nEn la plataforma Canvas encontrará un subconjunto de variables de la Encuesta Casen 2022. Realice los procedimientos indicados en el script, los cuales buscan practicar.\n\n- Operaciones de selección de columnas.\n- Operaciones de filtrado.\n- Conteos de variables.\n- Creación de variables y tablas resumen.\n- Uso de condiciones lógicas.\n\n##  {background-color=\"rgb(25,25,25)\"}\n\n::: center-xy\n::: large-text\n<br> ¡Gracias! <br> <https://sirojasv.github.io/tsm_web/>\n:::\n:::\n\n\n\n\n\n<script src=\"script.js\"></script>",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-after-body": [
        "\r\n<script>\r\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\r\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\r\n  // slide changes (different for each slide format).\r\n  (function () {\r\n    // dispatch for htmlwidgets\r\n    function fireSlideEnter() {\r\n      const event = window.document.createEvent(\"Event\");\r\n      event.initEvent(\"slideenter\", true, true);\r\n      window.document.dispatchEvent(event);\r\n    }\r\n\r\n    function fireSlideChanged(previousSlide, currentSlide) {\r\n      fireSlideEnter();\r\n\r\n      // dispatch for shiny\r\n      if (window.jQuery) {\r\n        if (previousSlide) {\r\n          window.jQuery(previousSlide).trigger(\"hidden\");\r\n        }\r\n        if (currentSlide) {\r\n          window.jQuery(currentSlide).trigger(\"shown\");\r\n        }\r\n      }\r\n    }\r\n\r\n    // hookup for slidy\r\n    if (window.w3c_slidy) {\r\n      window.w3c_slidy.add_observer(function (slide_num) {\r\n        // slide_num starts at position 1\r\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\r\n      });\r\n    }\r\n\r\n  })();\r\n</script>\r\n\r\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}